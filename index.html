<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web KÊ≠å - ÂëºÂê∏Á≤òÊªûÁâà</title>
    <style>
        /* =========================================
           ÂÖ®Â±ÄÊ†∑Âºè (‰øùÊåÅ‰∏çÂèò)
           ========================================= */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
        body { 
            background: linear-gradient(180deg, #0f0c29, #302b63, #24243e);
            color: #fff; 
            font-family: 'PingFang SC', sans-serif;
            height: 100dvh; width: 100vw; margin: 0; overflow: hidden; 
            display: flex; flex-direction: column; user-select: none; 
            padding-bottom: env(safe-area-inset-bottom);
        }

        /* È°∂ÈÉ®Ê†è */
        .top-bar {
            flex-shrink: 0; height: 56px; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; padding: 8px 16px; z-index: 20;
            background: rgba(20, 20, 35, 0.6); backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }
        .top-bar-content { width: 100%; display: flex; justify-content: space-between; align-items: center; }
        .select-wrapper { position: relative; width: 55%; }
        select {
            background: rgba(255, 255, 255, 0.1); color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 30px;
            padding: 6px 30px 6px 15px; font-size: 14px; width: 100%; outline: none;
        }
        select option { background-color: #ffffff; color: #000000; font-size: 14px; }
        .select-arrow { position: absolute; right: 12px; top: 50%; transform: translateY(-50%); pointer-events: none; font-size: 10px; color: #aaa; }
        
        /* Ë∞ÉËØïÁä∂ÊÄÅÊù° */
        .status-box {
            display: flex; gap: 4px; font-family: monospace; font-size: 10px;
        }
        .badge {
            padding: 4px 5px; border-radius: 4px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); color: #888;
        }
        .badge.active { background: #00d2ff; color: #000; font-weight: bold; }
        .badge.warn { background: #ff4b2b; color: #fff; }

        /* ÁîªÂ∏ÉÂå∫Âüü */
        #canvas-wrapper {
            flex: 1; position: relative; width: 100%; background: transparent;
            overflow: hidden; display: flex; justify-content: center; align-items: center; z-index: 10;
        }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }

        /* ÂàÜÊï∞Èù¢Êùø */
        .score-board { position: absolute; top: 12px; right: 15px; text-align: right; pointer-events: none; z-index: 15; }
        .score-value { 
            font-size: 80px; color: #fff; font-weight: 900; 
            text-shadow: 0 0 20px #00d2ff; line-height: 1;
            font-family: 'Arial Black', sans-serif;
        }
        .score-label { font-size: 12px; color: rgba(255,255,255,0.8); letter-spacing: 2px; font-weight: bold; margin-top: 5px; }

        /* ËøûÂáªÈù¢Êùø */
        .combo-board { position: absolute; bottom: 12px; left: 15px; text-align: left; pointer-events: none; z-index: 15; }
        .combo-value { font-size: 28px; color: #ffd700; font-weight: 900; text-shadow: 0 0 8px #ffd700; line-height: 1; }
        .combo-label { font-size: 11px; color: rgba(255,255,255,0.7); letter-spacing: 1px; font-weight: bold; }

        /* Â∫ïÈÉ®ÊéßÂà∂Ê†è */
        .bottom-controls {
            flex-shrink: 0; width: 100%; padding: 12px 16px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            display: flex; flex-direction: column; gap: 12px; z-index: 20;
            background: rgba(20, 20, 35, 0.75); backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }
        .vol-control { width: 100%; display: flex; flex-direction: column; gap: 6px; }
        .vol-header { display: flex; justify-content: space-between; font-size: 11px; color: rgba(255,255,255,0.6); }
        input[type=range] { width: 100%; height: 5px; border-radius: 3px; appearance: none; background: rgba(255, 255, 255, 0.1); outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #fff; border: 2px solid #00d2ff; }

        .btn-group { display: flex; gap: 10px; width: 100%; }
        .btn {
            flex: 1; height: 48px; border: none; border-radius: 24px;
            font-size: 15px; font-weight: 600; color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            display: flex; justify-content: center; align-items: center;
        }
        .btn:disabled { background: #3a3a4c !important; color: #888 !important; cursor: not-allowed; box-shadow: none; }
        .btn-main { background: linear-gradient(135deg, #00c6ff, #0072ff); }
        .btn-stop { background: linear-gradient(135deg, #ff416c, #ff4b2b); }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="top-bar-content">
            <div class="select-wrapper">
                <select id="songSelect"><option value="">ÂàùÂßãÂåñ‰∏≠...</option></select>
                <div class="select-arrow">‚ñº</div>
            </div>
            <div class="status-box">
                <div id="badge-vol" class="badge">Èü≥Èáè</div>
                <div id="badge-zcr" class="badge">Èü≥Ë¥®</div>
                <div id="badge-pitch" class="badge">Èü≥È´ò</div>
            </div>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="score-board">
            <div class="score-value" id="scoreEl">--</div>
            <div class="score-label">ÂΩìÂâçÂæóÂàÜ</div>
        </div>
        <div class="combo-board">
            <div class="combo-value" id="comboEl">0</div>
            <div class="combo-label">COMBO</div>
        </div>
    </div>

    <div class="bottom-controls">
        <div class="vol-control">
            <div class="vol-header"><span>üéµ ‰º¥Â•èÈü≥Èáè</span><span id="volText">70%</span></div>
            <input type="range" id="volSlider" min="0" max="100" step="1" value="70">
        </div>
        <div class="btn-group">
            <button id="stopBtn" class="btn btn-stop" disabled>ÂÅúÊ≠¢</button>
            <button id="startBtn" class="btn btn-main" disabled>ËØ∑ÈÄâÊ≠å</button>
        </div>
    </div>

    <audio id="bgmAudio" crossorigin="anonymous"></audio>

    <script>
        // ==========================================
        //  Web KÊ≠å - ÂëºÂê∏Á≤òÊªûÁâà (Ë∂ÖÁ∫ßËÉ∂Ê∞¥ÁÆóÊ≥ï)
        // ==========================================

        const AGORA_CONFIG = {
            lineCalcuScore: 100,  
            minCalcuScore: 30,    
            pitchTolerance: 3.5   
        };

        // ÂÖ®Â±ÄÂèòÈáè
        let playlist = [];
        let currentMelodyData = [];
        let audioCtx, analyser, micSource, bgmSourceNode, bgmGainNode;
        let dataArray;
        let isRunning = false;
        
        // --- Ê†∏ÂøÉËØÑÂàÜÁä∂ÊÄÅÊú∫ ---
        let currentVisualScore = 0; // Â±èÂπïÊòæÁ§∫ÂàÜ
        let lastStableScore = 0;    // ‰∏ä‰∏ÄÊ¨°ÁöÑÈ´òÂàÜ
        let scoreLockTimer = 0;     // Êç¢Ê∞î‰øùÊä§ËÆ°Êó∂Âô®
        let scoreUpdateThrottle = 0; // Âà∑Êñ∞È¢ëÁéáÈôêÂà∂

        // ÁªüËÆ°Áî®
        let totalScoreSum = 0;   
        let totalScoreCount = 0; 
        let comboCount = 0;          
        let maxCombo = 0;            
        
        let frameCounter = 0;
        let renderIndex = 0;
        
        const scoreEl = document.getElementById('scoreEl');
        const comboEl = document.getElementById('comboEl');
        const volSlider = document.getElementById('volSlider');
        const bgmAudio = document.getElementById('bgmAudio');
        const songSelect = document.getElementById('songSelect');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn'); 
        
        const badgeVol = document.getElementById('badge-vol');
        const badgeZcr = document.getElementById('badge-zcr');
        const badgePitch = document.getElementById('badge-pitch');

        let canvasWidth, canvasHeight;
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const VIEW_DURATION = 3.0; 
        const NOTE_HEIGHT = 12;    

        window.onload = async () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            volSlider.oninput = () => {
                const val = parseInt(volSlider.value);
                document.getElementById('volText').innerText = val + "%"; 
                if(bgmGainNode) bgmGainNode.gain.value = val / 100;
            };
            volSlider.oninput();

            try {
                const res = await fetch('playlist.json?t=' + Date.now());
                playlist = await res.json();
                let html = '<option value="" disabled selected>üëâ ËØ∑ÁÇπÂáªÈÄâÊã©Ê≠åÊõ≤</option>';
                playlist.forEach((song, index) => {
                    html += `<option value="${index}">${song.name}</option>`;
                });
                songSelect.innerHTML = html;
                songSelect.addEventListener('change', loadSongData);
            } catch (e) {
                songSelect.innerHTML = '<option>ÂàóË°®Âä†ËΩΩÂ§±Ë¥•</option>';
            }
            bgmAudio.addEventListener('ended', () => finishGame("ÊºîÂî±ÁªìÊùü"));
        };

        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvasWidth = wrapper.clientWidth;
            canvasHeight = wrapper.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            ctx.resetTransform(); 
            ctx.scale(dpr, dpr);  
        }

        async function loadSongData() {
            const index = songSelect.value;
            const song = playlist[index];
            if (!song) return;
            resetGameStates(); 
            startBtn.innerText = "‰∏ãËΩΩÊï∞ÊçÆ...";
            startBtn.disabled = true;
            stopBtn.disabled = true;
            try {
                bgmAudio.src = song.mp3;
                const res = await fetch(song.json);
                currentMelodyData = await res.json();
                startBtn.disabled = false;
                startBtn.innerText = "‚ñ∂ ÂºÄÂßãÊºîÂî±";
                startBtn.classList.remove('btn-stop');
                startBtn.classList.add('btn-main');
            } catch (e) {
                alert("Âä†ËΩΩÂ§±Ë¥•: " + e.message);
            }
        }

        function resetGameStates() {
            isRunning = false;
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
            renderIndex = 0;
            
            // ÈáçÁΩÆËØÑÂàÜ
            currentVisualScore = 0;
            scoreLockTimer = 0;
            lastStableScore = 0;
            totalScoreSum = 0; totalScoreCount = 0;
            comboCount = 0; maxCombo = 0;
            
            scoreEl.innerText = '--'; comboEl.innerText = '0';
            frameCounter = 0; 
        }

        function finishGame(reason) {
            isRunning = false;
            bgmAudio.pause();
            startBtn.disabled = false;
            startBtn.innerText = "ÈáçÊñ∞ÂºÄÂßã";
            stopBtn.disabled = true;
            
            let finalAvg = 0;
            if (totalScoreCount > 0) finalAvg = totalScoreSum / totalScoreCount;
            if (finalAvg < 60 && maxCombo > 10) finalAvg += 15; 
            finalAvg = Math.min(100, finalAvg);

            if (reason !== "Â∑≤ÂÅúÊ≠¢") {
                alert(`${reason}ÔºÅ\nÊúÄÁªàÁªºÂêàËØÑÂàÜ: ${Math.floor(finalAvg)}\nÊúÄÂ§ßËøûÂáª: ${maxCombo}`);
            }
        }

        stopBtn.onclick = () => { if (isRunning) finishGame("Â∑≤ÂÅúÊ≠¢"); };

        startBtn.onclick = async () => {
            startBtn.disabled = true;
            startBtn.innerText = "ÂêØÂä®‰∏≠...";
            stopBtn.disabled = true;
            resetGameStates();
            
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            
            if (!micSource) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { 
                            echoCancellation: true, 
                            autoGainControl: true,  
                            noiseSuppression: true, 
                            latency: 0 
                        } 
                    });
                    micSource = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; 
                    micSource.connect(analyser);
                    dataArray = new Float32Array(analyser.fftSize);
                } catch (e) {
                    alert("È∫¶ÂÖãÈ£é‰∏çÂèØÁî®");
                    startBtn.innerText = "Êó†È∫¶ÂÖãÈ£é";
                    startBtn.disabled = false;
                    return;
                }
            }
            try {
                if (!bgmSourceNode) {
                    bgmSourceNode = audioCtx.createMediaElementSource(bgmAudio);
                    bgmGainNode = audioCtx.createGain();
                    bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
                    bgmSourceNode.connect(bgmGainNode);
                    bgmGainNode.connect(audioCtx.destination);
                }
                await bgmAudio.play();
                isRunning = true;
                startBtn.innerText = "ÊºîÂî±‰∏≠...";
                stopBtn.disabled = false;
                loop();
            } catch (e) {
                alert("Êí≠ÊîæÂ§±Ë¥•: " + e.message);
                startBtn.disabled = false;
            }
        };

        // YIN ÁÆóÊ≥ï
        function getPitchYIN(float32AudioBuffer, sampleRate) {
            const threshold = 0.35; 
            const bufferSize = float32AudioBuffer.length;
            const yinBuffer = new Float32Array(bufferSize / 2);
            
            for (let t = 0; t < bufferSize / 2; t++) yinBuffer[t] = 0;
            for (let t = 1; t < bufferSize / 2; t++) {
                let sum = 0;
                for (let i = 0; i < bufferSize / 2; i+=2) {
                    const delta = float32AudioBuffer[i] - float32AudioBuffer[i + t];
                    sum += delta * delta;
                }
                yinBuffer[t] = sum;
            }

            yinBuffer[0] = 1;
            let runningSum = 0;
            for (let t = 1; t < bufferSize / 2; t++) {
                runningSum += yinBuffer[t];
                yinBuffer[t] *= t / runningSum;
            }

            let tau = -1;
            for (let t = 2; t < bufferSize / 2; t++) {
                if (yinBuffer[t] < threshold) {
                    while (t + 1 < bufferSize / 2 && yinBuffer[t + 1] < yinBuffer[t]) {
                        t++;
                    }
                    tau = t;
                    break;
                }
            }

            if (tau === -1) return -1; 
            return sampleRate / tau;
        }

        function calculateRMS(buffer) {
            let sum = 0;
            for (let i = 0; i < buffer.length; i += 4) sum += buffer[i] * buffer[i];
            return Math.sqrt(sum / (buffer.length / 4));
        }

        function calculateZCR(buffer) {
            let zcr = 0;
            for(let i=1; i<buffer.length; i+=2) { 
                if ((buffer[i-1] > 0 && buffer[i] <= 0) || (buffer[i-1] < 0 && buffer[i] >= 0)) zcr++;
            }
            return zcr / (buffer.length / 2); 
        }

        function calculatePitchAccuracy(userFreq, targetFreq) {
            if (userFreq <= 0 || targetFreq <= 0) return 999;
            const userNote = 12 * Math.log2(userFreq / 440) + 69;
            const targetNote = 12 * Math.log2(targetFreq / 440) + 69;
            let diff = Math.abs(userNote - targetNote) % 12;
            if (diff > 6) diff = 12 - diff;
            return diff; 
        }

        // Agora Á∫øÊÄßËØÑÂàÜ
        function calculateAgoraScore(diff) {
            if (diff > AGORA_CONFIG.pitchTolerance) return 0;
            let rawScore = 100 - (diff * 25);
            if (rawScore < AGORA_CONFIG.minCalcuScore) return 0;
            return Math.min(100, rawScore);
        }

        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            if (ctx.roundRect) ctx.roundRect(x, y, width, height, radius);
            else ctx.rect(x, y, width, height);
            ctx.fill();
        }

        function freqToY(freq) {
            const minF = 65, maxF = 1000;
            if (freq < minF) freq = minF;
            if (freq > maxF) freq = maxF;
            const percent = (Math.log(freq) - Math.log(minF)) / (Math.log(maxF) - Math.log(minF));
            return canvasHeight - (percent * canvasHeight);
        }

        // ==========================================
        // ‰∏ªÂæ™ÁéØ
        // ==========================================
        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            frameCounter++;
            const currentTime = bgmAudio.currentTime;

            let targetPitch = 0;
            for(let i = renderIndex; i < currentMelodyData.length; i++) {
                const item = currentMelodyData[i];
                if (Math.abs(item.t - currentTime) < 0.5) { 
                    targetPitch = item.p;
                    break;
                }
                if (item.t > currentTime + 0.5) break; 
            }

            // 2. Ê£ÄÊµã
            if (frameCounter % 3 === 0) {
                let userFreq = -1;
                let semitoneDiff = 999;
                
                analyser.getFloatTimeDomainData(dataArray);
                const userVolume = calculateRMS(dataArray);
                const zcr = calculateZCR(dataArray);
                
                // ÂÆΩÂÆπÈó®Êßõ
                if (userVolume > 0.005) {
                    badgeVol.classList.add('active');
                    if (zcr < 0.45) { // ÂÖÅËÆ∏ÂëºÂê∏Â£∞
                        badgeZcr.classList.add('active'); badgeZcr.classList.remove('warn');
                        const pitch = getPitchYIN(dataArray, audioCtx.sampleRate);
                        if (pitch > 65 && pitch < 1200) {
                            userFreq = pitch;
                            badgePitch.classList.add('active');
                            badgePitch.innerText = `F:${Math.floor(pitch)}`;
                        } else {
                            badgePitch.classList.remove('active');
                            badgePitch.innerText = "Êó†Ë∞É";
                        }
                    } else {
                        badgeZcr.classList.add('warn'); // Âô™Èü≥
                        badgeZcr.classList.remove('active');
                    }
                } else {
                    badgeVol.classList.remove('active');
                    badgeZcr.classList.remove('active', 'warn');
                    badgePitch.classList.remove('active');
                    badgePitch.innerText = "ÈùôÈü≥";
                }

                if (userFreq > 0 && targetPitch > 0) {
                    semitoneDiff = calculatePitchAccuracy(userFreq, targetPitch);
                }

                // =========================================
                // „ÄêÊ†∏ÂøÉÔºöË∂ÖÁ∫ßËÉ∂Ê∞¥ËØÑÂàÜÈÄªËæë„Äë
                // =========================================
                let instantScore = 0;
                
                if (targetPitch > 0) {
                    if (userFreq > 0) {
                        instantScore = calculateAgoraScore(semitoneDiff);
                        if (instantScore > 0) comboCount++;
                        else comboCount = 0;
                    } else {
                        instantScore = 0; // Miss
                        comboCount = 0;
                    }
                    totalScoreSum += instantScore;
                    totalScoreCount++;
                }

                // --- ÈÄªËæëË∞ÉÊï¥ÔºöÂ¶ÇÊûúËøô‰∏ÄÂ∏ßÂàÜÊï∞‰∏∫0ÔºàÊØîÂ¶ÇÊç¢Ê∞î/MissÔºâ ---
                // --- Êàë‰ª¨‰∏çÁõ¥Êé•Áî® 0ÔºåËÄåÊòØÁúã‚ÄúÈîÅÂÆöËÆ°Êó∂Âô®‚Äù ---
                let targetDisplay = 0;

                if (instantScore >= 50) {
                    // Âî±ÂæóÂ•ΩÔºÅÂà∑Êñ∞È´òÂàÜÔºåÂà∑Êñ∞ËÆ°Êó∂Âô®
                    lastStableScore = Math.max(88, instantScore); // ÊúÄ‰ΩéÁªô‰Ω†‰øùÂ∫ï88
                    scoreLockTimer = 180; // „ÄêÊ†∏ÂøÉ„ÄëÈîÅÂÆöÊó∂Èó¥Âª∂ÈïøÂà∞ 180Â∏ß (Á∫¶3-4Áßí)
                    targetDisplay = instantScore;
                } else {
                    // Ê≤°Âî±/Âî±Èîô‰∫Ü
                    if (scoreLockTimer > 0) {
                        // „ÄêËÉ∂Ê∞¥ÁîüÊïà„ÄëËøòÂú®‰øùÊä§ÊúüÔºåÂº∫Ë°åÊòæÁ§∫‰∏ä‰∏ÄÊ¨°ÁöÑÈ´òÂàÜÔºÅ
                        targetDisplay = lastStableScore;
                        scoreLockTimer--; // ÂÄíËÆ°Êó∂
                    } else {
                        // ‰øùÊä§ÊúüËøá‰∫ÜÔºåÂºÄÂßãÊéâÂàÜ
                        targetDisplay = 0;
                    }
                }

                // 3. ËßÜËßâÂπ≥Êªë (ÊûÅÊÖ¢Ë∑åËêΩ)
                if (targetDisplay > currentVisualScore) {
                    // Ê∂®ÂàÜÔºöÂø´ÈÄüË∑üËøõ (0.2)
                    currentVisualScore += (targetDisplay - currentVisualScore) * 0.2; 
                } else {
                    // ÊéâÂàÜÔºöÂ¶ÇÊûú‰∏çÂî±‰∫ÜÔºåÊØèÂ∏ßÂè™Êéâ‰∏ÄÁÇπÁÇπÔºåËßÜËßâ‰∏äÂÉèÁæΩÊØõ‰∏ÄÊ†∑È£ò‰∏ãÊù•
                    // ËÄå‰∏çÊòØÊåáÊï∞Á∫ß‰∏ãÈôç
                    if (currentVisualScore > 0) {
                        currentVisualScore -= 0.15; // Á∫øÊÄß‰∏ãÈôçÔºöÊØèÁßíÂ§ßÊ¶ÇÊéâ 9 ÂàÜ
                    }
                }

                maxCombo = Math.max(maxCombo, comboCount);
                
                // ÈôêÂà∂UIÂà∑Êñ∞È¢ëÁéá (ÊØè10Â∏ßÂà∑‰∏ÄÊ¨°Êï∞Â≠óÔºåÈò≤Ê≠¢Èó™ÁÉÅ)
                scoreUpdateThrottle++;
                if (scoreUpdateThrottle > 8) {
                    if (totalScoreCount === 0) scoreEl.innerText = "--";
                    else scoreEl.innerText = Math.floor(Math.max(0, currentVisualScore));
                    scoreUpdateThrottle = 0;
                }
                
                comboEl.innerText = comboCount;
                
                // 3. ÁªòÂõæ
                ctx.fillStyle = 'rgba(20, 20, 35, 0.4)'; 
                ctx.clearRect(0, 0, canvasWidth, canvasHeight); 
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1; ctx.beginPath();
                [130.81, 261.63, 523.25].forEach(f => { const y = freqToY(f); ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y); });
                ctx.stroke();

                const playerX = canvasWidth * 0.33;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.lineWidth = 2; ctx.beginPath(); 
                ctx.moveTo(playerX, 0); ctx.lineTo(playerX, canvasHeight); ctx.stroke();

                if (renderIndex >= currentMelodyData.length || currentMelodyData[renderIndex].t > currentTime + 10) renderIndex = 0;
                while (renderIndex < currentMelodyData.length - 1 && currentMelodyData[renderIndex].t < currentTime - 1) renderIndex++;

                for (let i = renderIndex; i < currentMelodyData.length; i++) {
                    const note = currentMelodyData[i];
                    if (note.t > currentTime + VIEW_DURATION) break; 
                    const drawX = playerX + (note.t - currentTime) / VIEW_DURATION * canvasWidth * 0.8; 
                    if (note.p <= 0 || drawX < -20) continue; 
                    const y = freqToY(note.p);
                    
                    let color = '#00d2ff'; let shadowBlur = 0;
                    if (Math.abs(drawX - playerX) < 20 && targetPitch > 0) { 
                        if (userFreq > 0) { 
                             const noteDiff = calculatePitchAccuracy(userFreq, note.p);
                             const noteScore = calculateAgoraScore(noteDiff);
                             if (noteScore >= 90) { color = '#ffffff'; shadowBlur = 12; }
                             else if (noteScore >= 70) { color = '#00ff9d'; shadowBlur = 8; }
                             else if (noteScore >= 30) { color = '#ffd700'; shadowBlur = 6; }
                             else { color = '#ff8800'; shadowBlur = 4; }
                        }
                    }
                    ctx.fillStyle = color; ctx.shadowBlur = shadowBlur; ctx.shadowColor = color;
                    drawRoundRect(ctx, drawX, y - NOTE_HEIGHT/2, 12, NOTE_HEIGHT, 5); ctx.shadowBlur = 0; 
                }

                if (userFreq > 0) {
                    let displayY = freqToY(userFreq);
                    if (targetPitch > 0 && semitoneDiff <= 3.5) {
                        displayY = freqToY(targetPitch);
                    }
                    ctx.beginPath(); ctx.arc(playerX, displayY, 10, 0, Math.PI * 2); 
                    let fillColor = '#ff00de'; let shadowColor = '#ff00de'; let shadowBlur = 8;
                    if (targetPitch > 0) {
                        let s = calculateAgoraScore(semitoneDiff);
                        if (s >= 90) { fillColor = '#ffffff'; shadowColor = '#00d2ff'; shadowBlur = 18; }
                        else if (s >= 70) { fillColor = '#00ff9d'; shadowColor = '#00ff9d'; shadowBlur = 15; }
                        else if (s >= 30) { fillColor = '#ffd700'; shadowColor = '#ffd700'; shadowBlur = 12; }
                    }
                    ctx.fillStyle = fillColor; ctx.shadowBlur = shadowBlur; ctx.shadowColor = shadowColor; ctx.fill(); ctx.shadowBlur = 0;
                }
            }
        }
    </script>
</body>
</html>
