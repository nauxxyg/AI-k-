<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Kæ­Œ - æœ€ç»ˆå®Œç¾ç‰ˆ (é™å™ª+å…«åº¦æ”¯æŒ)</title>
    <style>
        /* --- æ²‰æµ¸å¼æš—é»‘é£æ ¼ UI --- */
        body { 
            background: #111; 
            color: #eee; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            height: 100vh; 
            overflow: hidden; 
            margin: 0; 
            user-select: none;
        }

        /* é¡¶éƒ¨æ  */
        .top-bar {
            background: #1e1e1e;
            width: 100%;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            z-index: 10;
        }

        select {
            padding: 8px 12px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 16px;
            min-width: 220px;
            outline: none;
        }

        .status-badge {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #2a2a2a;
            color: #aaa;
            font-family: monospace;
        }

        /* ç”»å¸ƒåŒºåŸŸ */
        #canvas-wrapper {
            position: relative;
            flex: 1;
            width: 95%;
            margin: 20px 0;
            background: #000;
            border: 2px solid #333;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* åˆ†æ•°æ¿ */
        .score-board {
            position: absolute;
            top: 20px;
            right: 30px;
            text-align: right;
            pointer-events: none;
        }
        .score-label { font-size: 14px; color: #888; letter-spacing: 2px; }
        .score-value { 
            font-size: 64px; 
            color: #00ffcc; 
            font-weight: 700; 
            font-family: 'Courier New', monospace; 
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.4);
        }
        .score-suffix { font-size: 20px; color: #555; }

        /* åº•éƒ¨æ§åˆ¶æ  */
        .bottom-controls {
            height: 80px;
            width: 100%;
            background: #1e1e1e;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            border-top: 1px solid #333;
        }

        /* éŸ³é‡æ§åˆ¶ */
        .vol-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #2a2a2a;
            padding: 8px 15px;
            border-radius: 30px;
        }
        input[type=range] {
            accent-color: #00ffcc;
            cursor: pointer;
            width: 100px;
        }

        /* ä¸»æŒ‰é’® */
        .btn-main {
            padding: 12px 50px;
            cursor: pointer;
            background: linear-gradient(90deg, #00ffcc, #0099ff);
            color: #000;
            border: none;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
        }
        .btn-main:hover { transform: scale(1.05); filter: brightness(1.1); }
        .btn-main:active { transform: scale(0.95); }
        .btn-main:disabled { 
            background: #444; 
            color: #888; 
            cursor: not-allowed; 
            transform: none; 
            box-shadow: none;
        }

        #bgmAudio { display: none; }
    </style>
</head>
<body>

    <div class="top-bar">
        <div style="color:#888;">â™ª</div>
        <select id="songSelect">
            <option value="">æ­£åœ¨è¯»å–æ­Œå•...</option>
        </select>
        <div id="statusText" class="status-badge">ç­‰å¾…é€‰æ‹©</div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="score-board">
            <div class="score-label">å½“å‰å¾—åˆ†</div>
            <div class="score-value" id="scoreEl">0<span class="score-suffix">åˆ†</span></div>
        </div>
    </div>

    <div class="bottom-controls">
        <div class="vol-control">
            <span>ğŸ”Š ä¼´å¥</span>
            <input type="range" id="volSlider" min="0" max="1" step="0.05" value="0.7">
        </div>
        
        <button id="startBtn" class="btn-main" disabled>è¯·é€‰æ‹©æ­Œæ›²</button>
    </div>

    <audio id="bgmAudio" crossorigin="anonymous"></audio>

    <script>
        /**
         * Web Kæ­Œæ ¸å¿ƒé€»è¾‘ - æœ€ç»ˆå®Œç¾ç‰ˆ
         * åŒ…å«ï¼š
         * 1. AMDF æé€Ÿç®—æ³•
         * 2. 100åˆ†åˆ¶é€»è¾‘
         * 3. æ¸²æŸ“æŒ‡é’ˆä¼˜åŒ–
         * 4. æŠ—å™ªé™å™ª (è§£å†³å¹æ°”é£˜çº¢çƒ)
         * 5. å…«åº¦å…¼å®¹ (è§£å†³åˆ†æ•°è¿‡ä½)
         */

        // --- å…¨å±€å˜é‡ ---
        let playlist = [];
        let currentMelodyData = [];
        let audioCtx, analyser, micSource, bgmSourceNode, bgmGainNode;
        let dataArray;
        let isRunning = false;
        
        // --- æ ¸å¿ƒè¯„åˆ†å˜é‡ ---
        let score = 0;
        let totalVocalFrames = 0; // åŸå”±æœ‰å£°æ€»å¸§æ•° (åˆ†æ¯)
        let hitVocalFrames = 0;   // å‡»ä¸­å¸§æ•° (åˆ†å­)
        
        // æ¸²æŸ“ä¸çŠ¶æ€å˜é‡
        let frameCounter = 0;
        let renderIndex = 0; // æ¸²æŸ“æ¸¸æ ‡
        let lastUserFreq = -1;
        
        // DOM å…ƒç´ 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const songSelect = document.getElementById('songSelect');
        const startBtn = document.getElementById('startBtn');
        const statusText = document.getElementById('statusText');
        const scoreEl = document.getElementById('scoreEl');
        const volSlider = document.getElementById('volSlider');
        const bgmAudio = document.getElementById('bgmAudio');

        // è§†å›¾é…ç½®
        let canvasWidth, canvasHeight;
        const VIEW_DURATION = 4.5; // å±å¹•æ˜¾ç¤ºå¤šå°‘ç§’çš„å†…å®¹
        const NOTE_HEIGHT = 6;     // éŸ³ç¬¦æ–¹å—é«˜åº¦

        // --- åˆå§‹åŒ– ---
        window.onload = async () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            volSlider.oninput = () => {
                if(bgmGainNode) bgmGainNode.gain.value = volSlider.value;
            };

            // åŠ è½½æ­Œå•
            try {
                const res = await fetch('playlist.json?t=' + Date.now());
                playlist = await res.json();
                
                songSelect.innerHTML = '<option value="" disabled selected>-- è¯·é€‰æ‹©æ­Œæ›² --</option>';
                playlist.forEach((song, index) => {
                    const opt = document.createElement('option');
                    opt.value = index;
                    opt.innerText = song.name;
                    songSelect.appendChild(opt);
                });
                
                songSelect.addEventListener('change', loadSongData);
                statusText.innerText = "æ­Œå•å·²å°±ç»ª";
            } catch (e) {
                console.error(e);
                statusText.innerText = "é”™è¯¯ï¼šæ— æ³•è¯»å– playlist.json";
                alert("è¯·ç¡®ä¿ playlist.json å­˜åœ¨");
            }

            bgmAudio.addEventListener('ended', () => {
                isRunning = false;
                startBtn.disabled = false;
                startBtn.innerText = "å†æ¥ä¸€å±€";
                alert(`æ¼”å”±ç»“æŸï¼æœ€ç»ˆå¾—åˆ†: ${score}åˆ†`);
            });
        };

        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvasWidth = wrapper.clientWidth;
            canvasHeight = wrapper.clientHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        // --- åŠ è½½æ­Œæ›² ---
        async function loadSongData() {
            const index = songSelect.value;
            const song = playlist[index];
            if (!song) return;

            stopGame();
            statusText.innerText = "ä¸‹è½½æ•°æ®ä¸­...";
            startBtn.disabled = true;

            try {
                bgmAudio.src = song.mp3;
                const res = await fetch(song.json);
                currentMelodyData = await res.json();
                
                // --- é‡ç½®æ‰€æœ‰çŠ¶æ€ ---
                renderIndex = 0;
                score = 0;
                totalVocalFrames = 0;
                hitVocalFrames = 0;
                scoreEl.innerHTML = '0<span class="score-suffix">åˆ†</span>';
                
                statusText.innerText = "å‡†å¤‡å°±ç»ª";
                startBtn.disabled = false;
                startBtn.innerText = "â–¶ å¼€å§‹æ¼”å”±";
            } catch (e) {
                statusText.innerText = "æ•°æ®åŠ è½½å¤±è´¥";
                console.error(e);
            }
        }

        function stopGame() {
            isRunning = false;
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
        }

        // --- å¼€å§‹æ¸¸æˆ ---
        startBtn.onclick = async () => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            if (!micSource) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { 
                            echoCancellation: true, 
                            autoGainControl: false, // å…³é—­è‡ªåŠ¨å¢ç›Šï¼Œé¿å…å™ªéŸ³è¢«æ”¾å¤§
                            noiseSuppression: false, // æˆ‘ä»¬è‡ªå·±å¤„ç†é—¨é™
                            latency: 0 
                        } 
                    });
                    micSource = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; 
                    micSource.connect(analyser);
                    dataArray = new Float32Array(analyser.fftSize);
                } catch (e) {
                    alert("éœ€è¦éº¦å…‹é£æƒé™ï¼");
                    return;
                }
            }

            if (!bgmSourceNode) {
                bgmSourceNode = audioCtx.createMediaElementSource(bgmAudio);
                bgmGainNode = audioCtx.createGain();
                bgmGainNode.gain.value = volSlider.value;
                bgmSourceNode.connect(bgmGainNode);
                bgmGainNode.connect(audioCtx.destination);
            }

            try {
                await bgmAudio.play();
                isRunning = true;
                startBtn.disabled = true;
                startBtn.innerText = "æ¼”å”±ä¸­...";
                loop();
            } catch (e) {
                console.error(e);
                alert("æ’­æ”¾å¤±è´¥ï¼Œè¯·ç‚¹å‡»é¡µé¢åå†è¯•ã€‚");
            }
        };

        // --- ä¸»å¾ªç¯ (æ ¸å¿ƒé€»è¾‘) ---
        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            frameCounter++;
            const currentTime = bgmAudio.currentTime;

            // --- 0. æŸ¥æ‰¾å½“å‰æ—¶åˆ»çš„â€œæ ‡å‡†ç­”æ¡ˆâ€ ---
            let targetPitch = 0;
            // å¿«é€Ÿåœ¨ renderIndex é™„è¿‘æŸ¥æ‰¾
            for(let i = renderIndex; i < currentMelodyData.length; i++) {
                const item = currentMelodyData[i];
                if (Math.abs(item.t - currentTime) < 0.15) { // ç¨å¾®æ”¾å®½æ—¶é—´å¯¹é½çª—å£
                    targetPitch = item.p;
                    break;
                }
                if (item.t > currentTime + 0.15) break; 
            }

            // --- 1. æé€ŸéŸ³é«˜æ£€æµ‹ & ç®—åˆ† ---
            let userFreq = lastUserFreq;
            
            if (frameCounter % 3 === 0) {
                analyser.getFloatTimeDomainData(dataArray);
                const detected = getPitchAMDF(dataArray, audioCtx.sampleRate);
                
                if (detected > 0) {
                    userFreq = detected;
                    lastUserFreq = detected;
                } else {
                    if (frameCounter % 10 === 0) lastUserFreq = -1; // å¿«é€Ÿè¡°å‡
                }

                // >>> æ”¹è¿›åçš„å®½å®¹è¯„åˆ†é€»è¾‘ <<<
                if (targetPitch > 0) {
                    totalVocalFrames++; 

                    // æ£€æŸ¥æ˜¯å¦å”±å‡† (æ”¯æŒå…«åº¦ + å®½å®¹åº¦)
                    let isHit = false;
                    if (userFreq > 0) {
                        isHit = checkPitchHit(userFreq, targetPitch);
                    }

                    if (isHit) {
                        hitVocalFrames++;
                    }

                    // è®¡ç®—ç™¾åˆ†æ¯”
                    if (totalVocalFrames > 0) {
                        score = Math.floor((hitVocalFrames / totalVocalFrames) * 100);
                        scoreEl.innerHTML = score + '<span class="score-suffix">åˆ†</span>';
                    }
                }
            }

            // --- 2. ç»˜åˆ¶åœºæ™¯ ---
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // å‚è€ƒçº¿
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            [130.81, 261.63, 523.25].forEach(freq => {
                const y = freqToY(freq);
                ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y);
            });
            ctx.stroke();

            // åˆ¤å®šçº¿
            const playerX = canvasWidth * 0.2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(playerX, 0); ctx.lineTo(playerX, canvasHeight); ctx.stroke();

            // --- 3. æ¸²æŸ“éŸ³ç¬¦ ---
            if (renderIndex >= currentMelodyData.length || currentMelodyData[renderIndex].t > currentTime + 10) {
                 renderIndex = 0;
            }
            while (renderIndex < currentMelodyData.length - 1 && currentMelodyData[renderIndex].t < currentTime - 1) {
                renderIndex++;
            }

            for (let i = renderIndex; i < currentMelodyData.length; i++) {
                const note = currentMelodyData[i];
                if (note.t > currentTime + VIEW_DURATION) break;

                const x = (note.t - currentTime + 1) / VIEW_DURATION * canvasWidth;
                if (note.p <= 0) continue; 
                const y = freqToY(note.p);

                // é¢œè‰²é€»è¾‘ï¼šé»˜è®¤é’è‰²ï¼Œå¦‚æœæ­¤åˆ»æ­£åœ¨å‡»ä¸­ï¼Œå˜ç™½
                let color = '#00eebb'; 
                
                if (Math.abs(x - playerX) < 15) { // æ”¾å®½è§†è§‰åˆ¤å®šåŒº
                     if (userFreq > 0 && targetPitch > 0) {
                         if (checkPitchHit(userFreq, targetPitch)) {
                             color = '#ffffff'; // é«˜äº®
                         }
                     }
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(x, y - NOTE_HEIGHT/2, 6, NOTE_HEIGHT);
            }

            // --- 4. ç©å®¶å…‰æ ‡ ---
            if (userFreq > 0) {
                const userY = freqToY(userFreq);
                ctx.beginPath();
                ctx.arc(playerX, userY, 9, 0, Math.PI * 2);
                
                let isVisuallyHit = false;
                if (targetPitch > 0 && checkPitchHit(userFreq, targetPitch)) {
                    isVisuallyHit = true;
                }

                if (isVisuallyHit) {
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ffcc';
                } else {
                    ctx.fillStyle = '#ff3366'; // è·‘è°ƒçº¢
                    ctx.shadowBlur = 0;
                }
                
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // --- è¾…åŠ©å·¥å…· ---
        function freqToY(freq) {
            const minF = 65, maxF = 1000;
            if (freq < minF) freq = minF;
            if (freq > maxF) freq = maxF;
            const percent = (Math.log(freq) - Math.log(minF)) / (Math.log(maxF) - Math.log(minF));
            return canvasHeight - (percent * canvasHeight);
        }

        /**
         * åˆ¤å®šæ˜¯å¦å‡»ä¸­éŸ³é«˜ (æ”¯æŒå…«åº¦å…¼å®¹)
         */
        function checkPitchHit(user, target) {
            if (!user || !target) return false;
            const ratio = user / target;
            
            // å…è®¸ 12% çš„è¯¯å·® (æ¥è¿‘å…¨éŸ³)
            const marginLow = 0.88;
            const marginHigh = 1.12;

            // 1. åŸè°ƒåŒ¹é…
            if (ratio > marginLow && ratio < marginHigh) return true;
            // 2. ä½å…«åº¦åŒ¹é… (user æ˜¯ target çš„ 0.5 å€)
            if (ratio > (marginLow * 0.5) && ratio < (marginHigh * 0.5)) return true;
            // 3. é«˜å…«åº¦åŒ¹é… (user æ˜¯ target çš„ 2.0 å€)
            if (ratio > (marginLow * 2.0) && ratio < (marginHigh * 2.0)) return true;

            return false;
        }

        /**
         * AMDF (å¹³å‡å¹…åº¦å·®) æé€Ÿç®—æ³• - æŠ—å™ªå¢å¼ºç‰ˆ
         */
        function getPitchAMDF(buf, sampleRate) {
            const SIZE = buf.length;
            const MAX_SAMPLES = 1000; 
            const MIN_FREQ = 60;
            const MAX_FREQ = 800;
            
            const minPeriod = Math.floor(sampleRate / MAX_FREQ);
            const maxPeriod = Math.floor(sampleRate / MIN_FREQ);
            
            let minVal = Infinity;
            let bestPeriod = 0;

            // 1. é™éŸ³æ£€æµ‹ (RMS) - é˜ˆå€¼æé«˜åˆ° 0.04 æŠ—å‘¼å¸å£°
            let rms = 0;
            for (let i = 0; i < MAX_SAMPLES; i += 4) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / (MAX_SAMPLES / 4));
            if (rms < 0.04) return -1; 

            // 2. AMDF æ ¸å¿ƒ (å‡æ³•ä»£æ›¿ä¹˜æ³•ï¼Œéš”ç‚¹é‡‡æ ·)
            for (let offset = minPeriod; offset < maxPeriod; offset += 2) {
                let currentSum = 0;
                for (let i = 0; i < 300; i += 2) {
                    currentSum += Math.abs(buf[i] - buf[i + offset]);
                }
                if (currentSum < minVal) {
                    minVal = currentSum;
                    bestPeriod = offset;
                }
            }

            // 3. æ¸…æ™°åº¦æ ¡éªŒ (é˜²æ­¢é£å£°è¢«ç®—ä½œéŸ³é«˜)
            if (minVal < 120) { 
                return sampleRate / bestPeriod;
            }
            return -1;
        }

    </script>
</body>
</html>
