<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web Kæ­Œ - ç»ˆæä¸“ä¸šç‰ˆ</title>
    <style>
        /* =========================================
           1. å…¨å±€æ ·å¼é‡ç½® (Global Reset)
           ========================================= */
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent; /* å»é™¤ç‚¹å‡»é«˜äº® */
            touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º(æ»šåŠ¨ç­‰) */
        }
        
        body { 
            background: #111; 
            color: #eee; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            height: 100dvh; /* åŠ¨æ€è§†å£é«˜åº¦ï¼Œè§£å†³Safariåœ°å€æ é®æŒ¡ */
            width: 100vw;
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            user-select: none; /* ç¦æ­¢é•¿æŒ‰é€‰ä¸­æ–‡å­— */
        }

        /* =========================================
           2. é¡¶éƒ¨æ  (Header)
           ========================================= */
        .top-bar {
            flex-shrink: 0; 
            background: #1a1a1a;
            width: 100%;
            height: 50px; 
            display: flex;
            justify-content: space-between; 
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid #333;
            z-index: 20;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        /* æ­Œæ›²é€‰æ‹©ä¸‹æ‹‰æ¡† */
        select {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 20px;
            padding: 6px 25px 6px 15px; /* å³ä¾§ç•™ç©ºç»™ç®­å¤´ */
            font-size: 14px;
            max-width: 65%; 
            outline: none;
            appearance: none; /* å»é™¤é»˜è®¤ä¸‘é™‹çš„ç®­å¤´ */
            text-overflow: ellipsis;
            white-space: nowrap;
            /* è‡ªå®šä¹‰ä¸€ä¸ªå°ç®­å¤´ */
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: 8px auto;
        }

        /* çŠ¶æ€æ ‡ç­¾ */
        .status-badge {
            font-size: 12px;
            color: #00ffcc;
            background: rgba(0, 255, 204, 0.1);
            padding: 4px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 204, 0.2);
            white-space: nowrap;
        }

        /* =========================================
           3. æ¸¸æˆç”»å¸ƒåŒºåŸŸ (Main Canvas)
           ========================================= */
        #canvas-wrapper {
            flex: 1; /* è‡ªåŠ¨æ’‘æ»¡å‰©ä½™é«˜åº¦ */
            position: relative;
            width: 100%;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* æ‚¬æµ®åˆ†æ•°æ¿ */
        .score-board {
            position: absolute;
            top: 15px;
            right: 20px;
            text-align: right;
            pointer-events: none;
            z-index: 10;
        }
        .score-value { 
            font-size: 48px; 
            color: #00ffcc; 
            font-weight: 800; 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            text-shadow: 0 0 15px rgba(0, 255, 204, 0.6);
            transition: transform 0.1s;
        }
        .score-label { font-size: 12px; color: #888; letter-spacing: 2px; text-transform: uppercase; }

        /* =========================================
           4. åº•éƒ¨æ§åˆ¶æ  (Footer Controls)
           ========================================= */
        .bottom-controls {
            flex-shrink: 0; 
            background: #1a1a1a;
            width: 100%;
            /* é€‚é… iPhone åº•éƒ¨å®‰å…¨åŒºï¼Œé˜²æ­¢æ¨ªæ¡é®æŒ¡ */
            padding: 12px 20px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #333;
            gap: 15px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        }

        /* éŸ³é‡æ§åˆ¶ç»„ (çºµå‘æ’åˆ—) */
        .vol-control {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 6px;
            background: #252525;
            padding: 8px 15px;
            height: 54px;
            border-radius: 12px;
            border: 1px solid #333;
        }
        
        .vol-header {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #aaa;
            width: 100%;
        }
        .vol-num { color: #00ffcc; font-weight: bold; font-family: monospace; }

        /* æ»‘å—ç¾åŒ– */
        input[type=range] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            appearance: none;
            background: #444;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ffcc;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
        }

        /* å¼€å§‹æŒ‰é’® */
        .btn-main {
            min-width: 100px;
            height: 54px;
            padding: 0 20px;
            background: linear-gradient(135deg, #00ffcc, #0099ff);
            color: #000;
            border: none;
            border-radius: 12px; /* æ–¹åœ†è§’ï¼Œæ›´ç°ä»£ */
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.2);
            transition: transform 0.1s, filter 0.1s;
        }
        .btn-main:active { transform: scale(0.95); filter: brightness(0.9); }
        .btn-main:disabled { 
            background: #333; 
            color: #666; 
            box-shadow: none; 
            transform: none;
            cursor: not-allowed;
        }

        /* =========================================
           5. æ¨ªå±æç¤ºé®ç½© (Rotate Hint)
           ========================================= */
        #rotate-hint {
            display: none; /* JSæ§åˆ¶æˆ–CSSåª’ä½“æŸ¥è¯¢æ§åˆ¶ */
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.92);
            z-index: 999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        .rotate-icon { font-size: 50px; margin-bottom: 20px; animation: rotate Anim 2s infinite; }
        .rotate-text { font-size: 18px; color: #ccc; }
        
        @keyframes rotateAnim {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-90deg); }
            100% { transform: rotate(-90deg); }
        }

        /* åª’ä½“æŸ¥è¯¢ï¼šä»…åœ¨æ‰‹æœºç«–å±æ—¶æ˜¾ç¤ºé®ç½© */
        @media screen and (orientation: portrait) and (max-width: 600px) {
            #rotate-hint { display: flex; }
        }

        #bgmAudio { display: none; }
    </style>
</head>
<body>

    <div id="rotate-hint">
        <div class="rotate-icon">ğŸ“±</div>
        <div class="rotate-text">è¯·å°†æ‰‹æœº<b>æ¨ªå±</b>ä½¿ç”¨<br>ä»¥è·å¾—æœ€ä½³ K æ­Œä½“éªŒ</div>
    </div>

    <div class="top-bar">
        <select id="songSelect">
            <option value="">æ­£åœ¨åˆå§‹åŒ–...</option>
        </select>
        <div id="statusText" class="status-badge">ç­‰å¾…é€‰æ‹©</div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="score-board">
            <div class="score-label">SCORE</div>
            <div class="score-value" id="scoreEl">0</div>
        </div>
    </div>

    <div class="bottom-controls">
        <div class="vol-control">
            <div class="vol-header">
                <span>ğŸ¤ ä¼´å¥éŸ³é‡</span>
                <span class="vol-num" id="volText">70%</span>
            </div>
            <input type="range" id="volSlider" min="0" max="100" step="1" value="70">
        </div>
        <button id="startBtn" class="btn-main" disabled>è¯·é€‰æ­Œ</button>
    </div>

    <audio id="bgmAudio" crossorigin="anonymous"></audio>

    <script>
        // ==========================================
        //  Web Kæ­Œæ ¸å¿ƒå¼•æ“ - Ultimate Edition
        // ==========================================

        // --- å…¨å±€å˜é‡ ---
        let playlist = [];
        let currentMelodyData = [];
        let audioCtx, analyser, micSource, bgmSourceNode, bgmGainNode;
        let dataArray;
        let isRunning = false;
        
        // --- è¯„åˆ†é€»è¾‘å˜é‡ ---
        let score = 0;
        let totalVocalFrames = 0; // åˆ†æ¯
        let hitVocalFrames = 0;   // åˆ†å­
        
        // --- æ¸²æŸ“å¾ªç¯å˜é‡ ---
        let frameCounter = 0;
        let renderIndex = 0;
        let lastUserFreq = -1;
        
        // --- DOM å¼•ç”¨ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // ä¼˜åŒ–æ€§èƒ½
        const songSelect = document.getElementById('songSelect');
        const startBtn = document.getElementById('startBtn');
        const statusText = document.getElementById('statusText');
        const scoreEl = document.getElementById('scoreEl');
        
        // éŸ³é‡æ§ä»¶
        const volSlider = document.getElementById('volSlider');
        const volText = document.getElementById('volText');
        
        const bgmAudio = document.getElementById('bgmAudio');

        // --- è§†å£é…ç½® ---
        let canvasWidth, canvasHeight;
        const VIEW_DURATION = 4.0; // è§†é‡ç§’æ•°
        const NOTE_HEIGHT = 12;    // éŸ³ç¬¦é«˜åº¦(åŠ ç²—)

        // ============================
        // 1. åˆå§‹åŒ– (Setup)
        // ============================
        window.onload = async () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // --- éŸ³é‡è°ƒèŠ‚é€»è¾‘ (100çº§) ---
            volSlider.oninput = () => {
                const val = parseInt(volSlider.value);
                volText.innerText = val + "%"; // æ›´æ–°UI
                if(bgmGainNode) {
                    // è½¬æ¢ä¸º Web Audio API éœ€è¦çš„ 0.0 - 1.0
                    bgmGainNode.gain.value = val / 100;
                }
            };

            // --- åŠ è½½æ­Œå• ---
            try {
                // åŠ æ—¶é—´æˆ³é˜²æ­¢ç¼“å­˜
                const res = await fetch('playlist.json?t=' + Date.now());
                playlist = await res.json();
                
                songSelect.innerHTML = '<option value="" disabled selected>ğŸ‘‰ ç‚¹å‡»é€‰æ‹©æ­Œæ›²</option>';
                playlist.forEach((song, index) => {
                    const opt = document.createElement('option');
                    opt.value = index;
                    opt.innerText = song.name;
                    songSelect.appendChild(opt);
                });
                
                songSelect.addEventListener('change', loadSongData);
                statusText.innerText = "å‡†å¤‡å°±ç»ª";
            } catch (e) {
                console.error(e);
                statusText.innerText = "åˆ—è¡¨åŠ è½½å¤±è´¥";
                statusText.style.color = "#ff3366";
                alert("æ— æ³•è¯»å– playlist.jsonï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸Šä¼ ã€‚");
            }

            // --- æ’­æ”¾ç»“æŸé€»è¾‘ ---
            bgmAudio.addEventListener('ended', () => {
                isRunning = false;
                startBtn.disabled = false;
                startBtn.innerText = "å†æ¥ä¸€å±€";
                alert(`æ¼”å”±ç»“æŸï¼æœ€ç»ˆå¾—åˆ†: ${score}`);
            });
        };

        // Canvas é«˜æ¸…é€‚é… (Retina)
        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvasWidth = wrapper.clientWidth;
            canvasHeight = wrapper.clientHeight;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            
            ctx.resetTransform(); 
            ctx.scale(dpr, dpr);  
        }

        // ============================
        // 2. æ•°æ®åŠ è½½ (Data Loading)
        // ============================
        async function loadSongData() {
            const index = songSelect.value;
            const song = playlist[index];
            if (!song) return;

            stopGame();
            statusText.innerText = "ä¸‹è½½æ•°æ®...";
            startBtn.disabled = true;

            try {
                bgmAudio.src = song.mp3;
                const res = await fetch(song.json);
                currentMelodyData = await res.json();
                
                // é‡ç½®çŠ¶æ€
                renderIndex = 0;
                score = 0;
                totalVocalFrames = 0;
                hitVocalFrames = 0;
                scoreEl.innerText = '0';
                
                statusText.innerText = "åŠ è½½å®Œæ¯•";
                startBtn.disabled = false;
                startBtn.innerText = "â–¶ å¼€å§‹æ¼”å”±";
            } catch (e) {
                console.error(e);
                statusText.innerText = "æ•°æ®é”™è¯¯";
                alert("åŠ è½½æ­Œæ›²æ•°æ®å¤±è´¥ (404 Not Found)");
            }
        }

        function stopGame() {
            isRunning = false;
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
        }

        // ============================
        // 3. æ¸¸æˆå¯åŠ¨ (Start)
        // ============================
        startBtn.onclick = async () => {
            // åˆå§‹åŒ– AudioContext
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            // éº¦å…‹é£å¤„ç† (æŠ—å™ªé…ç½®)
            if (!micSource) {
                try {
                    statusText.innerText = "è¯·æ±‚æƒé™...";
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { 
                            echoCancellation: true, 
                            autoGainControl: false, // å…³é”®ï¼šå…³é—­è‡ªåŠ¨å¢ç›Šä»¥å‡å°‘èƒŒæ™¯å™ªéŸ³
                            noiseSuppression: false, 
                            latency: 0 
                        } 
                    });
                    micSource = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; 
                    micSource.connect(analyser);
                    dataArray = new Float32Array(analyser.fftSize);
                } catch (e) {
                    alert("æ— æ³•è·å–éº¦å…‹é£æƒé™ï¼\n(è¯·ç¡®ä¿ä½¿ç”¨äº† HTTPS æˆ–æœ¬åœ° localhost)");
                    statusText.innerText = "æ— æƒé™";
                    return;
                }
            }

            // ä¼´å¥è¿æ¥ä¸éŸ³é‡åˆå§‹åŒ–
            if (!bgmSourceNode) {
                bgmSourceNode = audioCtx.createMediaElementSource(bgmAudio);
                bgmGainNode = audioCtx.createGain();
                // ä½¿ç”¨å½“å‰çš„ slider å€¼åˆå§‹åŒ–éŸ³é‡
                bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
                
                bgmSourceNode.connect(bgmGainNode);
                bgmGainNode.connect(audioCtx.destination);
            } else {
                // å¦‚æœæ˜¯é‡ç©ï¼Œä¹Ÿè¦ç¡®ä¿éŸ³é‡æ­£ç¡®
                bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
            }

            try {
                await bgmAudio.play();
                isRunning = true;
                startBtn.disabled = true;
                startBtn.innerText = "æ¼”å”±ä¸­...";
                loop();
            } catch (e) {
                alert("æ’­æ”¾å¤±è´¥ï¼Œè¯·ç‚¹å‡»å±å¹•é‡è¯•");
            }
        };

        // ============================
        // 4. æ¸¸æˆå¾ªç¯ (Main Loop)
        // ============================
        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            frameCounter++;
            const currentTime = bgmAudio.currentTime;

            // --- A. æŸ¥æ‰¾ç›®æ ‡éŸ³é«˜ (Target Pitch) ---
            let targetPitch = 0;
            for(let i = renderIndex; i < currentMelodyData.length; i++) {
                const item = currentMelodyData[i];
                if (Math.abs(item.t - currentTime) < 0.15) { 
                    targetPitch = item.p;
                    break;
                }
                if (item.t > currentTime + 0.15) break; 
            }

            // --- B. éº¦å…‹é£éŸ³é«˜æ£€æµ‹ (Microphone Pitch) ---
            let userFreq = lastUserFreq;
            // é™é¢‘æ£€æµ‹ï¼šæ¯3å¸§ç®—ä¸€æ¬¡ï¼Œçœç”µ
            if (frameCounter % 3 === 0) {
                analyser.getFloatTimeDomainData(dataArray);
                const detected = getPitchAMDF(dataArray, audioCtx.sampleRate);
                
                if (detected > 0) {
                    userFreq = detected;
                    lastUserFreq = detected;
                } else {
                    // å£°éŸ³è¡°å‡é˜²æŠ–
                    if (frameCounter % 10 === 0) lastUserFreq = -1; 
                }

                // --- è¯„åˆ†é€»è¾‘ (Scoring) ---
                if (targetPitch > 0) {
                    totalVocalFrames++; 
                    if (userFreq > 0 && checkPitchHit(userFreq, targetPitch)) {
                        hitVocalFrames++;
                    }
                    if (totalVocalFrames > 0) {
                        // å®æ—¶è®¡ç®—åˆ†æ•°
                        score = Math.floor((hitVocalFrames / totalVocalFrames) * 100);
                        scoreEl.innerText = score;
                    }
                }
            }

            // --- C. ç»˜å›¾ (Rendering) ---
            
            // 1. æ¸…ç©ºèƒŒæ™¯
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // 2. ç»˜åˆ¶å‚è€ƒçº¿ (Reference Lines)
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            [130.81, 261.63, 523.25].forEach(freq => {
                const y = freqToY(freq);
                ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y);
            });
            ctx.stroke();

            // 3. ç»˜åˆ¶åˆ¤å®šçº¿ (Playhead) - ä½äºå±å¹•å·¦ä¾§ 25%
            const playerX = canvasWidth * 0.25;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(playerX, 0); ctx.lineTo(playerX, canvasHeight); ctx.stroke();

            // 4. ç»˜åˆ¶éŸ³ç¬¦ (Notes)
            // æ¸¸æ ‡é€»è¾‘ï¼šè·³è¿‡å·²è¿‡æœŸçš„éŸ³ç¬¦
            if (renderIndex >= currentMelodyData.length || currentMelodyData[renderIndex].t > currentTime + 10) renderIndex = 0;
            while (renderIndex < currentMelodyData.length - 1 && currentMelodyData[renderIndex].t < currentTime - 1) renderIndex++;

            for (let i = renderIndex; i < currentMelodyData.length; i++) {
                const note = currentMelodyData[i];
                if (note.t > currentTime + VIEW_DURATION) break; // è¶…å‡ºå±å¹•å³ä¾§ä¸ç”»

                // è®¡ç®— X è½´ï¼šåŸºäºæ—¶é—´å·®çš„æ»šåŠ¨é€»è¾‘
                const drawX = playerX + (note.t - currentTime) / VIEW_DURATION * canvasWidth;

                // è¶…å‡ºå±å¹•å·¦ä¾§æˆ–æ— æ•ˆéŸ³é«˜ä¸ç”»
                if (note.p <= 0 || drawX < -30) continue; 
                
                const y = freqToY(note.p);
                let color = '#00eebb'; // é»˜è®¤é¢œè‰²

                // è§†è§‰åˆ¤å®šåé¦ˆ
                if (Math.abs(drawX - playerX) < 15) { 
                     if (userFreq > 0 && targetPitch > 0 && checkPitchHit(userFreq, targetPitch)) {
                         color = '#ffffff'; // å‡»ä¸­å˜ç™½
                     }
                }
                
                ctx.fillStyle = color;
                // ä½¿ç”¨å…¼å®¹æ€§å‡½æ•°ç»˜åˆ¶åœ†è§’çŸ©å½¢
                drawRoundRect(ctx, drawX, y - NOTE_HEIGHT/2, 14, NOTE_HEIGHT, 5);
            }

            // 5. ç»˜åˆ¶ç©å®¶å…‰æ ‡ (Cursor)
            if (userFreq > 0) {
                const userY = freqToY(userFreq);
                ctx.beginPath();
                ctx.arc(playerX, userY, 10, 0, Math.PI * 2);
                
                if (targetPitch > 0 && checkPitchHit(userFreq, targetPitch)) {
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffcc';
                } else {
                    ctx.fillStyle = '#ff3366'; // è·‘è°ƒçº¢è‰²
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // ============================
        // 5. è¾…åŠ©å‡½æ•° (Utils)
        // ============================

        // æ‰‹åŠ¨ç»˜åˆ¶åœ†è§’çŸ©å½¢ (å…¼å®¹æ—§ç‰ˆæœ¬ iOS/Android WebView)
        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // é¢‘ç‡ -> Yè½´åæ ‡ (å¯¹æ•°æ˜ å°„)
        function freqToY(freq) {
            const minF = 65, maxF = 1000;
            if (freq < minF) freq = minF;
            if (freq > maxF) freq = maxF;
            const percent = (Math.log(freq) - Math.log(minF)) / (Math.log(maxF) - Math.log(minF));
            return canvasHeight - (percent * canvasHeight);
        }

        // å®½å®¹åˆ¤å®šé€»è¾‘ (æ”¯æŒå…«åº¦)
        function checkPitchHit(user, target) {
            if (!user || !target) return false;
            const ratio = user / target;
            const marginLow = 0.88, marginHigh = 1.12; // æ¥è¿‘å…¨éŸ³çš„å®½å®¹åº¦
            
            // åŸè°ƒã€ä½å…«åº¦ã€é«˜å…«åº¦ç»Ÿç»Ÿç®—å¯¹
            if (ratio > marginLow && ratio < marginHigh) return true; 
            if (ratio > (marginLow * 0.5) && ratio < (marginHigh * 0.5)) return true; 
            if (ratio > (marginLow * 2.0) && ratio < (marginHigh * 2.0)) return true; 
            return false;
        }

        // AMDF éŸ³é«˜æ£€æµ‹ç®—æ³• (æŠ—å™ªç‰ˆ)
        function getPitchAMDF(buf, sampleRate) {
            const SIZE = buf.length, MAX_SAMPLES = 1000; 
            const minPeriod = Math.floor(sampleRate/800), maxPeriod = Math.floor(sampleRate/60);
            let minVal = Infinity, bestPeriod = 0;

            // RMS é™éŸ³é—¨é™ï¼š0.04 (è¿‡æ»¤å‘¼å¸å£°)
            let rms = 0;
            for (let i = 0; i < MAX_SAMPLES; i += 4) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / (MAX_SAMPLES / 4));
            if (rms < 0.04) return -1; 

            // AMDF æ ¸å¿ƒ
            for (let offset = minPeriod; offset < maxPeriod; offset += 2) {
                let currentSum = 0;
                for (let i = 0; i < 300; i += 2) currentSum += Math.abs(buf[i] - buf[i + offset]);
                if (currentSum < minVal) { minVal = currentSum; bestPeriod = offset; }
            }
            // æ¸…æ™°åº¦é˜ˆå€¼
            return (minVal < 120) ? sampleRate / bestPeriod : -1;
        }
    </script>
</body>
</html>
