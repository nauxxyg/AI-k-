<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web Kæ­Œ - æ‰‹æœºä¸“ä¸šç‰ˆ</title>
    <style>
        /* --- å…¨å±€æ ·å¼é‡ç½® --- */
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent; /* å»é™¤ç‚¹å‡»é«˜äº® */
            touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º(æ»šåŠ¨ç­‰) */
        }
        
        body { 
            background: #111; 
            color: #eee; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100dvh; /* åŠ¨æ€è§†å£é«˜åº¦ï¼Œè§£å†³Safariåœ°å€æ é®æŒ¡ */
            width: 100vw;
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            user-select: none; /* ç¦æ­¢é•¿æŒ‰é€‰ä¸­æ–‡å­— */
        }

        /* --- 1. é¡¶éƒ¨æ  (Header) --- */
        .top-bar {
            flex-shrink: 0; 
            background: #1a1a1a;
            width: 100%;
            height: 50px; 
            display: flex;
            justify-content: space-between; 
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid #333;
            z-index: 20;
        }

        select {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 20px;
            padding: 6px 15px;
            font-size: 14px;
            max-width: 60%; 
            outline: none;
            appearance: none; /* å»é™¤é»˜è®¤ä¸‹æ‹‰ç®­å¤´ */
            text-align: center;
        }

        .status-badge {
            font-size: 12px;
            color: #00ffcc;
            background: rgba(0, 255, 204, 0.1);
            padding: 4px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 204, 0.2);
        }

        /* --- 2. æ¸¸æˆç”»å¸ƒ (Main) --- */
        #canvas-wrapper {
            flex: 1; /* è‡ªåŠ¨æ’‘æ»¡å‰©ä½™é«˜åº¦ */
            position: relative;
            width: 100%;
            background: #000;
            overflow: hidden;
            /* å±…ä¸­ loading æç¤º */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* æ‚¬æµ®åˆ†æ•°æ¿ */
        .score-board {
            position: absolute;
            top: 15px;
            right: 20px;
            text-align: right;
            pointer-events: none;
            z-index: 10;
        }
        .score-value { 
            font-size: 42px; 
            color: #00ffcc; 
            font-weight: 800; 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }
        .score-label { font-size: 12px; color: #888; letter-spacing: 1px; }

        /* --- 3. åº•éƒ¨æ§åˆ¶æ  (Footer) --- */
        .bottom-controls {
            flex-shrink: 0; 
            background: #1a1a1a;
            width: 100%;
            padding: 12px 20px;
            /* é€‚é… iPhone åº•éƒ¨å®‰å…¨åŒº */
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #333;
            gap: 15px;
        }

        /* éŸ³é‡æ¡å®¹å™¨ */
        .vol-control {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
            background: #252525;
            padding: 0 15px;
            height: 44px;
            border-radius: 22px;
        }
        .vol-label { font-size: 12px; color: #aaa; white-space: nowrap; }
        input[type=range] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            accent-color: #00ffcc; /* å®‰å“/æ–°ç‰ˆChromeå˜è‰² */
            cursor: pointer;
        }

        /* å¼€å§‹æŒ‰é’® */
        .btn-main {
            min-width: 100px;
            height: 44px;
            padding: 0 20px;
            background: linear-gradient(135deg, #00ffcc, #0099ff);
            color: #000;
            border: none;
            border-radius: 22px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.3);
            transition: transform 0.1s;
        }
        .btn-main:active { transform: scale(0.92); filter: brightness(0.9); }
        .btn-main:disabled { 
            background: #333; 
            color: #666; 
            box-shadow: none; 
            transform: none;
        }

        /* --- æ¨ªå±æç¤ºå±‚ --- */
        #rotate-hint {
            display: none; /* é»˜è®¤éšè— */
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9);
            z-index: 999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }
        #rotate-hint span { font-size: 40px; margin-bottom: 20px; display: block; }

        /* å½“å±å¹•å¾ˆçª„æ—¶ï¼ˆç«–å±ï¼‰ï¼Œå»ºè®®æ¨ªå± */
        @media screen and (max-width: 500px) {
            /* å¯ä»¥åœ¨è¿™é‡ŒæŠŠ #rotate-hint è®¾ä¸º flex æ¥å¼ºåˆ¶æ¨ªå±ï¼Œ
               ä½†ä¸ºäº†ä¸æ‰“æ‰°ç”¨æˆ·ï¼Œæˆ‘ä»¬åªè°ƒæ•´UIå¤§å° */
            .score-value { font-size: 32px; }
        }

        #bgmAudio { display: none; }
    </style>
</head>
<body>

    <div class="top-bar">
        <select id="songSelect">
            <option value="">æ­£åœ¨åˆå§‹åŒ–...</option>
        </select>
        <div id="statusText" class="status-badge">ç­‰å¾…é€‰æ‹©</div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="score-board">
            <div class="score-label">SCORE</div>
            <div class="score-value" id="scoreEl">0</div>
        </div>
    </div>

    <div class="bottom-controls">
        <div class="vol-control">
            <span class="vol-label">ğŸ¤ ä¼´å¥éŸ³é‡</span>
            <input type="range" id="volSlider" min="0" max="1" step="0.05" value="0.7">
        </div>
        <button id="startBtn" class="btn-main" disabled>è¯·é€‰æ­Œ</button>
    </div>

    <audio id="bgmAudio" crossorigin="anonymous"></audio>

    <script>
        // ==========================================
        //  Web Kæ­Œæ ¸å¿ƒå¼•æ“ - Mobile Professional
        // ==========================================

        // --- å…¨å±€çŠ¶æ€ ---
        let playlist = [];
        let currentMelodyData = [];
        let audioCtx, analyser, micSource, bgmSourceNode, bgmGainNode;
        let dataArray;
        let isRunning = false;
        
        // --- è¯„åˆ†ç›¸å…³ ---
        let score = 0;
        let totalVocalFrames = 0; // åŸå”±æœ‰å£°æ€»å¸§æ•°
        let hitVocalFrames = 0;   // å‡»ä¸­å¸§æ•°
        
        // --- æ¸²æŸ“å¾ªç¯ç›¸å…³ ---
        let frameCounter = 0;
        let renderIndex = 0;
        let lastUserFreq = -1;
        
        // --- DOM å…ƒç´ å¼•ç”¨ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // å…³é—­é€æ˜å±‚åŠ é€Ÿæ¸²æŸ“
        const songSelect = document.getElementById('songSelect');
        const startBtn = document.getElementById('startBtn');
        const statusText = document.getElementById('statusText');
        const scoreEl = document.getElementById('scoreEl');
        const volSlider = document.getElementById('volSlider');
        const bgmAudio = document.getElementById('bgmAudio');

        // --- è§†å£é…ç½® ---
        let canvasWidth, canvasHeight;
        const VIEW_DURATION = 4.0; // å±å¹•æ˜¾ç¤º4ç§’å†…å®¹ï¼Œé€‚åˆæ‰‹æœº
        const NOTE_HEIGHT = 10;    // éŸ³ç¬¦åŠ ç²—ï¼Œæ–¹ä¾¿çœ‹æ¸…

        // ============================
        // 1. åˆå§‹åŒ–ä¸äº‹ä»¶ç»‘å®š
        // ============================
        window.onload = async () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // éŸ³é‡å®æ—¶è°ƒèŠ‚
            volSlider.oninput = () => {
                if(bgmGainNode) bgmGainNode.gain.value = volSlider.value;
            };

            // åŠ è½½æ­Œå•åˆ—è¡¨
            try {
                const res = await fetch('playlist.json?t=' + Date.now());
                playlist = await res.json();
                
                songSelect.innerHTML = '<option value="" disabled selected>ğŸ‘‰ è¯·ç‚¹å‡»é€‰æ‹©æ­Œæ›²</option>';
                playlist.forEach((song, index) => {
                    const opt = document.createElement('option');
                    opt.value = index;
                    opt.innerText = song.name;
                    songSelect.appendChild(opt);
                });
                
                songSelect.addEventListener('change', loadSongData);
                statusText.innerText = "å‡†å¤‡å°±ç»ª";
            } catch (e) {
                console.error(e);
                statusText.innerText = "åˆ—è¡¨åŠ è½½å¤±è´¥";
                statusText.style.color = "#ff3366";
                alert("æ— æ³•è¯»å– playlist.jsonï¼Œè¯·ç¡®ä¿æ–‡ä»¶å­˜åœ¨ã€‚");
            }

            // ç›‘å¬æ’­æ”¾ç»“æŸ
            bgmAudio.addEventListener('ended', () => {
                isRunning = false;
                startBtn.disabled = false;
                startBtn.innerText = "å†æ¥ä¸€å±€";
                alert(`æ¼”å”±ç»“æŸï¼ä½ çš„å¾—åˆ†æ˜¯: ${score}`);
            });
        };

        // é€‚é…é«˜æ¸…å±å¹• (Retina Display)
        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvasWidth = wrapper.clientWidth;
            canvasHeight = wrapper.clientHeight;
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            
            ctx.resetTransform(); // é‡ç½®çŸ©é˜µ
            ctx.scale(dpr, dpr);  // ç¼©æ”¾ç»˜å›¾ä¸Šä¸‹æ–‡
        }

        // ============================
        // 2. åŠ è½½æ­Œæ›²æ•°æ®
        // ============================
        async function loadSongData() {
            const index = songSelect.value;
            const song = playlist[index];
            if (!song) return;

            stopGame();
            statusText.innerText = "ä¸‹è½½æ•°æ®ä¸­...";
            startBtn.disabled = true;

            try {
                bgmAudio.src = song.mp3;
                const res = await fetch(song.json);
                currentMelodyData = await res.json();
                
                // é‡ç½®æ‰€æœ‰çŠ¶æ€
                renderIndex = 0;
                score = 0;
                totalVocalFrames = 0;
                hitVocalFrames = 0;
                scoreEl.innerText = '0';
                
                statusText.innerText = "åŠ è½½å®Œæ¯•";
                startBtn.disabled = false;
                startBtn.innerText = "â–¶ å¼€å§‹";
            } catch (e) {
                console.error(e);
                statusText.innerText = "æ•°æ®é”™è¯¯";
                alert("æ— æ³•åŠ è½½æ­Œæ›²æ•°æ® (JSON/MP3 404)");
            }
        }

        function stopGame() {
            isRunning = false;
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
        }

        // ============================
        // 3. å¯åŠ¨æ¸¸æˆ (å¤„ç†éŸ³é¢‘æƒé™)
        // ============================
        startBtn.onclick = async () => {
            // åˆå§‹åŒ– AudioContext (å¿…é¡»åœ¨ç‚¹å‡»äº‹ä»¶ä¸­è§¦å‘)
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            // è·å–éº¦å…‹é£æµ
            if (!micSource) {
                try {
                    statusText.innerText = "è¯·æ±‚éº¦å…‹é£...";
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { 
                            echoCancellation: true, // å›å£°æ¶ˆé™¤
                            autoGainControl: false, // ç¦æ­¢è‡ªåŠ¨å¢ç›Š(é˜²æ­¢å™ªéŸ³æ”¾å¤§)
                            noiseSuppression: false, 
                            latency: 0 
                        } 
                    });
                    micSource = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; 
                    micSource.connect(analyser);
                    dataArray = new Float32Array(analyser.fftSize);
                } catch (e) {
                    alert("æ— æ³•è·å–éº¦å…‹é£æƒé™ï¼Œæ— æ³•è¯„åˆ†ï¼");
                    statusText.innerText = "æ— æƒé™";
                    return;
                }
            }

            // è¿æ¥ä¼´å¥
            if (!bgmSourceNode) {
                bgmSourceNode = audioCtx.createMediaElementSource(bgmAudio);
                bgmGainNode = audioCtx.createGain();
                bgmGainNode.gain.value = volSlider.value;
                bgmSourceNode.connect(bgmGainNode);
                bgmGainNode.connect(audioCtx.destination);
            }

            // æ’­æ”¾
            try {
                await bgmAudio.play();
                isRunning = true;
                startBtn.disabled = true;
                startBtn.innerText = "æ¼”å”±ä¸­...";
                loop();
            } catch (e) {
                alert("æ’­æ”¾å¤±è´¥ï¼Œè¯·é‡è¯•");
            }
        };

        // ============================
        // 4. æ¸¸æˆä¸»å¾ªç¯ (Render Loop)
        // ============================
        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            frameCounter++;
            const currentTime = bgmAudio.currentTime;

            // --- A. æŸ¥æ‰¾å½“å‰æ—¶åˆ»çš„ç›®æ ‡éŸ³é«˜ ---
            let targetPitch = 0;
            // ç®€å•çš„æœç´¢ä¼˜åŒ–ï¼šä»ä¸Šæ¬¡æ¸²æŸ“çš„ä½ç½®é™„è¿‘å¼€å§‹æ‰¾
            for(let i = renderIndex; i < currentMelodyData.length; i++) {
                const item = currentMelodyData[i];
                if (Math.abs(item.t - currentTime) < 0.15) { 
                    targetPitch = item.p;
                    break;
                }
                // å¦‚æœæ•°æ®å·²ç»è¶…è¿‡å½“å‰æ—¶é—´å¤ªè¿œï¼Œå°±ä¸ç”¨æ‰¾äº†
                if (item.t > currentTime + 0.15) break; 
            }

            // --- B. éº¦å…‹é£éŸ³é«˜æ£€æµ‹ (æ¯3å¸§ç®—ä¸€æ¬¡ï¼Œçœç”µ) ---
            let userFreq = lastUserFreq;
            if (frameCounter % 3 === 0) {
                analyser.getFloatTimeDomainData(dataArray);
                const detected = getPitchAMDF(dataArray, audioCtx.sampleRate);
                
                if (detected > 0) {
                    userFreq = detected;
                    lastUserFreq = detected;
                } else {
                    // å£°éŸ³è¡°å‡å¤„ç†ï¼š10å¸§æ²¡å£°éŸ³æ‰å½’é›¶ï¼Œé¿å…é—ªçƒ
                    if (frameCounter % 10 === 0) lastUserFreq = -1; 
                }

                // --- è¯„åˆ†é€»è¾‘ ---
                if (targetPitch > 0) {
                    totalVocalFrames++; 
                    if (userFreq > 0 && checkPitchHit(userFreq, targetPitch)) {
                        hitVocalFrames++;
                    }
                    if (totalVocalFrames > 0) {
                        // å®æ—¶è®¡ç®—ç™¾åˆ†æ¯”
                        score = Math.floor((hitVocalFrames / totalVocalFrames) * 100);
                        scoreEl.innerText = score;
                    }
                }
            }

            // --- C. ç»˜åˆ¶ ---
            
            // 1. æ¸…ç©ºèƒŒæ™¯
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // 2. ç»˜åˆ¶äº”çº¿è°±å‚è€ƒçº¿
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            [130.81, 261.63, 523.25].forEach(freq => {
                const y = freqToY(freq);
                ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y);
            });
            ctx.stroke();

            // 3. ç»˜åˆ¶åˆ¤å®šçº¿ (å›ºå®šåœ¨å·¦ä¾§ 25% å¤„)
            const playerX = canvasWidth * 0.25;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(playerX, 0); ctx.lineTo(playerX, canvasHeight); ctx.stroke();

            // 4. ç»˜åˆ¶éŸ³ç¬¦ (æ»šåŠ¨é€»è¾‘)
            // æ¸¸æ ‡ä¿®æ­£ï¼šå¦‚æœè¿›åº¦è¢«æ‹–æ‹½ï¼Œé‡ç½®æ¸¸æ ‡
            if (renderIndex >= currentMelodyData.length || currentMelodyData[renderIndex].t > currentTime + 10) renderIndex = 0;
            // å¿«é€Ÿè·³è¿‡è¿‡æœŸéŸ³ç¬¦
            while (renderIndex < currentMelodyData.length - 1 && currentMelodyData[renderIndex].t < currentTime - 1) renderIndex++;

            for (let i = renderIndex; i < currentMelodyData.length; i++) {
                const note = currentMelodyData[i];
                // è¶…å‡ºå±å¹•å³ä¾§åˆ™åœæ­¢ç»˜åˆ¶
                if (note.t > currentTime + VIEW_DURATION) break;

                // è®¡ç®— X è½´åæ ‡ (æ ¸å¿ƒæ»šåŠ¨å…¬å¼)
                // playerX æ˜¯å½“å‰æ—¶é—´ç‚¹ï¼Œ(note.t - currentTime) æ˜¯æ—¶é—´å·®
                const drawX = playerX + (note.t - currentTime) / VIEW_DURATION * canvasWidth;

                // å±å¹•å·¦ä¾§å¤–çš„ä¸ç”¨ç”»
                if (note.p <= 0 || drawX < -20) continue; 
                
                const y = freqToY(note.p);
                let color = '#00eebb'; // é»˜è®¤é’è‰²

                // è§†è§‰åˆ¤å®šï¼šå½“éŸ³ç¬¦ç»è¿‡åˆ¤å®šçº¿é™„è¿‘
                if (Math.abs(drawX - playerX) < 15) { 
                     // å¦‚æœæ­¤æ—¶å”±å¯¹äº†ï¼Œå˜ç™½
                     if (userFreq > 0 && targetPitch > 0 && checkPitchHit(userFreq, targetPitch)) {
                         color = '#ffffff'; 
                     }
                }
                
                ctx.fillStyle = color;
                // æ‰‹åŠ¨ç»˜åˆ¶åœ†è§’çŸ©å½¢ (å…¼å®¹æ—§æ‰‹æœº)
                drawRoundRect(ctx, drawX, y - NOTE_HEIGHT/2, 12, NOTE_HEIGHT, 4);
            }

            // 5. ç»˜åˆ¶ç©å®¶å…‰æ ‡
            if (userFreq > 0) {
                const userY = freqToY(userFreq);
                ctx.beginPath();
                ctx.arc(playerX, userY, 10, 0, Math.PI * 2);
                
                if (targetPitch > 0 && checkPitchHit(userFreq, targetPitch)) {
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffcc';
                } else {
                    ctx.fillStyle = '#ff3366'; // è·‘è°ƒçº¢
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // ============================
        // 5. è¾…åŠ©ç®—æ³•ä¸å‡½æ•°
        // ============================

        // å…¼å®¹æ€§åœ†è§’çŸ©å½¢ç»˜åˆ¶
        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // é¢‘ç‡è½¬ Y åæ ‡ (å¯¹æ•°æ˜ å°„)
        function freqToY(freq) {
            const minF = 65, maxF = 1000;
            if (freq < minF) freq = minF;
            if (freq > maxF) freq = maxF;
            const percent = (Math.log(freq) - Math.log(minF)) / (Math.log(maxF) - Math.log(minF));
            return canvasHeight - (percent * canvasHeight);
        }

        // åˆ¤å®šæ˜¯å¦å‡»ä¸­ (æ”¯æŒå…«åº¦å®¹é”™)
        function checkPitchHit(user, target) {
            if (!user || !target) return false;
            const ratio = user / target;
            const marginLow = 0.88, marginHigh = 1.12; // å®½æ¾åˆ¤å®š
            
            if (ratio > marginLow && ratio < marginHigh) return true; // åŸè°ƒ
            if (ratio > (marginLow * 0.5) && ratio < (marginHigh * 0.5)) return true; // ä½å…«åº¦
            if (ratio > (marginLow * 2.0) && ratio < (marginHigh * 2.0)) return true; // é«˜å…«åº¦
            return false;
        }

        // AMDF éŸ³é«˜æ£€æµ‹ (æŠ—å™ªç‰ˆ)
        function getPitchAMDF(buf, sampleRate) {
            const SIZE = buf.length, MAX_SAMPLES = 1000; 
            const minPeriod = Math.floor(sampleRate/800), maxPeriod = Math.floor(sampleRate/60);
            let minVal = Infinity, bestPeriod = 0;

            // å™ªéŸ³é—¨é™ï¼š0.04 (é¿å…å‘¼å¸å£°)
            let rms = 0;
            for (let i = 0; i < MAX_SAMPLES; i += 4) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / (MAX_SAMPLES / 4));
            if (rms < 0.04) return -1; 

            // æ ¸å¿ƒè®¡ç®—
            for (let offset = minPeriod; offset < maxPeriod; offset += 2) {
                let currentSum = 0;
                for (let i = 0; i < 300; i += 2) currentSum += Math.abs(buf[i] - buf[i + offset]);
                if (currentSum < minVal) { minVal = currentSum; bestPeriod = offset; }
            }
            return (minVal < 120) ? sampleRate / bestPeriod : -1;
        }
    </script>
</body>
</html>
