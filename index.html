<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web KÊ≠å - ‰∏ì‰∏öÈò≤ËØØËß¶ÁâàÔºà100ÂàÜÂà∂Ôºâ</title>
    <style>
        /* =========================================
           1. ÂÖ®Â±ÄÊ†∑Âºè & Âä®ÊÄÅËÉåÊôØ
           ========================================= */
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent; 
            touch-action: none; 
        }
        
        body { 
            /* Ê∑±ÈÇÉÁöÑÁ¥´ËìùÊ∏êÂèòËÉåÊôØ */
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #fff; 
            font-family: 'PingFang SC', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
            height: 100dvh; 
            width: 100vw;
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            user-select: none; 
        }

        body::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.03) 0%, transparent 60%);
            animation: bgPulse 10s infinite alternate;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes bgPulse {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.1); opacity: 0.8; }
        }

        /* =========================================
           2. È°∂ÈÉ®Ê†è
           ========================================= */
        .top-bar {
            flex-shrink: 0; 
            height: 60px; 
            display: flex;
            justify-content: space-between; 
            align-items: center;
            padding: 0 20px;
            z-index: 20;
            background: rgba(20, 20, 35, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
        }

        .select-wrapper {
            position: relative;
            max-width: 60%;
            flex: 1;
        }
        
        select {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            padding: 8px 35px 8px 15px;
            font-size: 15px;
            width: 100%;
            outline: none;
            appearance: none; 
            font-weight: 500;
            transition: all 0.3s;
        }
        select option {
            background-color: #1a1a1a;
            color: #fff;
        }
        select:focus {
            background: rgba(255, 255, 255, 0.2);
            border-color: #00d2ff;
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.3);
        }
        
        .select-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: 10px;
            color: #aaa;
        }

        .status-badge {
            font-size: 12px;
            color: #00d2ff;
            background: rgba(0, 210, 255, 0.1);
            padding: 5px 12px;
            border-radius: 20px;
            border: 1px solid rgba(0, 210, 255, 0.3);
            white-space: nowrap;
            letter-spacing: 1px;
            margin-left: 10px;
        }

        /* =========================================
           3. ÁîªÂ∏É & ÂàÜÊï∞
           ========================================= */
        #canvas-wrapper {
            flex: 1; 
            position: relative;
            width: 100%;
            background: transparent;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .score-board {
            position: absolute;
            top: 20px;
            right: 25px;
            text-align: right;
            pointer-events: none;
            z-index: 15;
        }
        
        .score-value { 
            font-size: 56px; 
            color: #fff; 
            font-weight: 900; 
            font-family: 'Segoe UI', Roboto, sans-serif; 
            text-shadow: 0 0 10px #ff00de, 0 0 20px #ff00de;
            line-height: 1;
        }
        .score-label { 
            font-size: 12px; 
            color: rgba(255,255,255,0.7); 
            letter-spacing: 4px; 
            font-weight: bold;
            margin-top: 5px;
        }
        /* Êñ∞Â¢ûÔºöËøûÂáªÊèêÁ§∫ */
        .combo-board {
            position: absolute;
            bottom: 20px;
            left: 25px;
            text-align: left;
            pointer-events: none;
            z-index: 15;
        }
        .combo-value {
            font-size: 32px;
            color: #ffd700;
            font-weight: 900;
            text-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700;
            line-height: 1;
        }
        .combo-label {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            letter-spacing: 2px;
            font-weight: bold;
        }

        /* =========================================
           4. Â∫ïÈÉ®Ê†è
           ========================================= */
        .bottom-controls {
            flex-shrink: 0; 
            width: 100%;
            padding: 15px 25px;
            padding-bottom: max(15px, env(safe-area-inset-bottom));
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            z-index: 20;
            background: rgba(20, 20, 35, 0.75);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.4);
        }

        .vol-control {
            flex: 1; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 8px;
        }
        
        .vol-header {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            padding: 0 2px;
        }
        .vol-num { color: #00d2ff; font-weight: bold; }

        input[type=range] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            border: 2px solid #00d2ff;
            transform: translateY(-1px);
        }

        .btn-group {
            display: flex;
            gap: 12px;
        }

        .btn {
            height: 50px;
            padding: 0 24px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            white-space: nowrap;
            letter-spacing: 0.5px;
            position: relative;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .btn:active { transform: scale(0.96); }
        .btn:disabled { 
            background: #3a3a4c !important; 
            color: #888 !important; 
            box-shadow: none !important;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .btn-main {
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            box-shadow: 0 4px 20px rgba(0, 114, 255, 0.4);
        }
        .btn-stop {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
            box-shadow: 0 4px 20px rgba(255, 75, 43, 0.4);
        }

        /* =========================================
           5. Ê®™Â±èÊèêÁ§∫
           ========================================= */
        #rotate-hint {
            display: none;
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: #0f0c29;
            z-index: 999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        .rotate-icon { 
            font-size: 60px; 
            margin-bottom: 20px; 
            animation: rotateAnim 2s infinite; 
            filter: drop-shadow(0 0 10px #00d2ff);
        }
        @keyframes rotateAnim {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-90deg); }
            100% { transform: rotate(-90deg); }
        }
        @media screen and (orientation: portrait) and (max-width: 600px) {
            #rotate-hint { display: flex; }
        }
    </style>
</head>
<body>

    <div id="rotate-hint">
        <div class="rotate-icon">üì±</div>
        <div style="line-height: 1.6;">ËØ∑Â∞ÜÊâãÊú∫<b>Ê®™Â±è</b>‰ΩøÁî®<br><span style="color:#888; font-size:14px;">Ëé∑Âæó KTV Á∫ß‰ΩìÈ™å</span></div>
    </div>

    <div class="top-bar">
        <div class="select-wrapper">
            <select id="songSelect">
                <option value="">Ê≠£Âú®ÂàùÂßãÂåñ...</option>
            </select>
            <div class="select-arrow">‚ñº</div>
        </div>
        <div id="statusText" class="status-badge">Á≠âÂæÖÈÄâÊã©</div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="score-board">
            <div class="score-value" id="scoreEl">0</div>
            <div class="score-label">SCORE</div>
        </div>
        <!-- Êñ∞Â¢ûÔºöËøûÂáªÈù¢Êùø -->
        <div class="combo-board">
            <div class="combo-value" id="comboEl">0</div>
            <div class="combo-label">COMBO</div>
        </div>
    </div>

    <div class="bottom-controls">
        <div class="vol-control">
            <div class="vol-header">
                <span>üéµ ‰º¥Â•èÈü≥Èáè</span>
                <span class="vol-num" id="volText">70%</span>
            </div>
            <input type="range" id="volSlider" min="0" max="100" step="1" value="70">
        </div>
        
        <div class="btn-group">
            <button id="stopBtn" class="btn btn-stop" disabled>ÂÅúÊ≠¢</button>
            <button id="startBtn" class="btn btn-main" disabled>ËØ∑ÈÄâÊ≠å</button>
        </div>
    </div>

    <audio id="bgmAudio" crossorigin="anonymous">

    <script>
        // ==========================================
        //  Web KÊ≠åÊ†∏ÂøÉÂºïÊìé - 100ÂàÜÂà∂‰ºòÂåñÁâà
        // ==========================================

        let playlist = [];
        let currentMelodyData = [];
        let audioCtx, analyser, micSource, bgmSourceNode, bgmGainNode;
        let dataArray;
        let isRunning = false;
        
        // ËØÑÂàÜÊ†∏ÂøÉÂèòÈáèÔºà100ÂàÜÂà∂‰ºòÂåñÔºâ
        let score = 0;
        let comboCount = 0;          // ËøûÂáªÊï∞
        let maxCombo = 0;            // ÊúÄÂ§ßËøûÂáª
        let totalNoteCount = 0;      // ÊÄªÈü≥Á¨¶Êï∞
        let hitNoteCount = 0;        // ÂëΩ‰∏≠Èü≥Á¨¶Êï∞
        let perfectHitCount = 0;     // ÂÆåÁæéÂëΩ‰∏≠Êï∞
        let lastHitTime = 0;         // ÊúÄÂêéÂëΩ‰∏≠Êó∂Èó¥ÔºàÈò≤Ë°∞ÂáèÔºâ
        let volumeWeight = 1.0;      // Èü≥ÈáèÊùÉÈáç
        
        let frameCounter = 0;
        let renderIndex = 0;
        let lastUserFreq = -1;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const songSelect = document.getElementById('songSelect');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn'); 
        const statusText = document.getElementById('statusText');
        const scoreEl = document.getElementById('scoreEl');
        const comboEl = document.getElementById('comboEl'); // ËøûÂáªÂÖÉÁ¥†
        const volSlider = document.getElementById('volSlider');
        const volText = document.getElementById('volText');
        const bgmAudio = document.getElementById('bgmAudio');

        let canvasWidth, canvasHeight;
        const VIEW_DURATION = 4.0; 
        const NOTE_HEIGHT = 14; 
        // ËØÑÂàÜÂ∏∏ÈáèÔºà100ÂàÜÂà∂Ê†∏ÂøÉÈÖçÁΩÆÔºâ
        const MAX_SCORE = 100;       // Êª°ÂàÜ100ÂàÜ
        const NOTE_BASE_SCORE = 1.0; // Âçï‰∏™Èü≥Á¨¶Âü∫Á°ÄÂàÜÔºàÂä®ÊÄÅË∞ÉÊï¥ÔºåÁ°Æ‰øùÊÄªÂàÜ‚â§100Ôºâ
        const COMBO_MULTIPLIER = 0.05; // ËøûÂáª‰πòÊï∞ÔºàÊØèËøûÂáª+5%ÔºåÊúÄÂ§ß1.5ÂÄçÔºâ
        const VOLUME_THRESHOLD = 0.1; // Èü≥ÈáèÈòàÂÄºÔºàËøáÊª§ÂëºÂê∏Â£∞Ôºâ
        const SCORE_DECAY_RATE = 0.2; // ÂàÜÊï∞Ë°∞ÂáèÁéáÔºàÊØèÁßíË°∞Âáè2ÂàÜÔºâ
        const PERFECT_RANGE = 0.05;   // ÂÆåÁæéÈü≥ÂáÜËåÉÂõ¥Ôºà¬±5%Ôºâ
        const GREAT_RANGE = 0.10;     // ‰ºòÁßÄÈü≥ÂáÜËåÉÂõ¥Ôºà¬±10%Ôºâ
        const GOOD_RANGE = 0.15;      // ËâØÂ•ΩÈü≥ÂáÜËåÉÂõ¥Ôºà¬±15%Ôºâ

        window.onload = async () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            volSlider.oninput = () => {
                const val = parseInt(volSlider.value);
                volText.innerText = val + "%"; 
                const percent = (val / 100) * 100;
                volSlider.style.background = `linear-gradient(to right, #00d2ff 0%, #00d2ff ${percent}%, rgba(255,255,255,0.1) ${percent}%, rgba(255,255,255,0.1) 100%)`;

                if(bgmGainNode) {
                    bgmGainNode.gain.value = val / 100;
                }
            };
            volSlider.oninput();

            try {
                const res = await fetch('playlist.json?t=' + Date.now());
                playlist = await res.json();
                
                songSelect.innerHTML = '<option value="" disabled selected>üëâ ÁÇπÂáªËøôÈáåÈÄâÊã©Ê≠åÊõ≤</option>';
                playlist.forEach((song, index) => {
                    const opt = document.createElement('option');
                    opt.value = index;
                    opt.innerText = song.name;
                    songSelect.appendChild(opt);
                });
                
                songSelect.addEventListener('change', loadSongData);
                statusText.innerText = "ÂáÜÂ§áÂ∞±Áª™";
            } catch (e) {
                console.error(e);
                statusText.innerText = "ÂàóË°®Âä†ËΩΩÂ§±Ë¥•";
                alert("Êó†Ê≥ïËØªÂèñ playlist.json");
            }

            bgmAudio.addEventListener('ended', () => {
                finishGame("ÊºîÂî±ÁªìÊùü");
            });
        };

        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvasWidth = wrapper.clientWidth;
            canvasHeight = wrapper.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            ctx.resetTransform(); 
            ctx.scale(dpr, dpr);  
        }

        async function loadSongData() {
            const index = songSelect.value;
            const song = playlist[index];
            if (!song) return;

            resetGameStates(); 
            
            statusText.innerText = "‰∏ãËΩΩÊï∞ÊçÆ...";
            startBtn.disabled = true;
            stopBtn.disabled = true;

            try {
                bgmAudio.src = song.mp3;
                const res = await fetch(song.json);
                currentMelodyData = await res.json();
                // ÁªüËÆ°ÊÄªÈü≥Á¨¶Êï∞Ôºà‰ªÖÊúâÊïàÈü≥Á¨¶Ôºâ
                totalNoteCount = currentMelodyData.filter(note => note.p > 0).length;
                // Âä®ÊÄÅË∞ÉÊï¥Âçï‰∏™Èü≥Á¨¶Âü∫Á°ÄÂàÜÔºàÁ°Æ‰øùÊâÄÊúâÈü≥Á¨¶ÂÆåÁæéÂëΩ‰∏≠Êó∂ÊÄªÂàÜ=100Ôºâ
                const adjustedBaseScore = totalNoteCount > 0 ? MAX_SCORE / totalNoteCount : 1.0;
                
                statusText.innerText = "Âä†ËΩΩÂÆåÊØï";
                startBtn.disabled = false;
                startBtn.innerText = "‚ñ∂ ÂºÄÂßãÊºîÂî±";
                startBtn.classList.remove('btn-stop');
                startBtn.classList.add('btn-main');
            } catch (e) {
                console.error(e);
                statusText.innerText = "Êï∞ÊçÆÈîôËØØ";
                alert("Âä†ËΩΩÊ≠åÊõ≤Êï∞ÊçÆÂ§±Ë¥•");
            }
        }

        function resetGameStates() {
            isRunning = false;
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
            renderIndex = 0;
            // ÈáçÁΩÆËØÑÂàÜÂèòÈáè
            score = 0;
            comboCount = 0;
            maxCombo = 0;
            totalNoteCount = 0;
            hitNoteCount = 0;
            perfectHitCount = 0;
            lastHitTime = 0;
            volumeWeight = 1.0;
            
            scoreEl.innerText = '0'; 
            comboEl.innerText = '0'; // ÈáçÁΩÆËøûÂáªÊòæÁ§∫
            frameCounter = 0;
            lastUserFreq = -1;
        }

        function finishGame(reason) {
            isRunning = false;
            startBtn.disabled = false;
            startBtn.innerText = "ÈáçÊñ∞ÂºÄÂßã";
            stopBtn.disabled = true;
            statusText.innerText = "ÁªìÁÆó‰∏≠";
            
            // ÁªìÁÆóÁªüËÆ°Ôºà100ÂàÜÂà∂Ôºâ
            const accuracy = totalNoteCount > 0 ? (hitNoteCount / totalNoteCount) * 100 : 0;
            const perfectRate = hitNoteCount > 0 ? (perfectHitCount / hitNoteCount) * 100 : 0;
            const finalScore = Math.min(MAX_SCORE, Math.max(0, Math.floor(score)));
            
            alert(`${reason}ÔºÅ
ÊúÄÁªàÂæóÂàÜ: ${finalScore} / ${MAX_SCORE}
ÊúÄÂ§ßËøûÂáª: ${maxCombo}
ÂáÜÁ°ÆÁéá: ${accuracy.toFixed(1)}%
ÂÆåÁæéÁéá: ${perfectRate.toFixed(1)}%`);
        }

        stopBtn.onclick = () => {
            if (isRunning) {
                isRunning = false;
                bgmAudio.pause();
                bgmAudio.currentTime = 0;
                
                stopBtn.disabled = true;
                startBtn.disabled = false;
                startBtn.innerText = "ÈáçÊñ∞ÂºÄÂßã";
                statusText.innerText = "Â∑≤ÂÅúÊ≠¢";
                
                // ÁªìÁÆóÁªüËÆ°Ôºà100ÂàÜÂà∂Ôºâ
                const accuracy = totalNoteCount > 0 ? (hitNoteCount / totalNoteCount) * 100 : 0;
                const perfectRate = hitNoteCount > 0 ? (perfectHitCount / hitNoteCount) * 100 : 0;
                const finalScore = Math.min(MAX_SCORE, Math.max(0, Math.floor(score)));
                
                alert(`Â∑≤ÂÅúÊ≠¢ÊºîÂî±„ÄÇ
ÊúÄÁªàÂæóÂàÜ: ${finalScore} / ${MAX_SCORE}
ÊúÄÂ§ßËøûÂáª: ${maxCombo}
ÂáÜÁ°ÆÁéá: ${accuracy.toFixed(1)}%
ÂÆåÁæéÁéá: ${perfectRate.toFixed(1)}%`);
            }
        };

        startBtn.onclick = async () => {
            startBtn.disabled = true;
            startBtn.innerText = "ÂêØÂä®‰∏≠...";
            stopBtn.disabled = true;

            resetGameStates();

            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            const tasks = [];
            if (audioCtx.state === 'suspended') tasks.push(audioCtx.resume());

            if (!micSource) {
                const micTask = navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: true, 
                        autoGainControl: false, 
                        noiseSuppression: false, 
                        latency: 0 
                    } 
                }).then(stream => {
                    micSource = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; 
                    micSource.connect(analyser);
                    dataArray = new Float32Array(analyser.fftSize);
                }).catch(e => {
                    alert("È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù");
                    throw e;
                });
                tasks.push(micTask);
            }

            if (bgmAudio.readyState < 3) bgmAudio.load();

            try {
                await Promise.all(tasks);

                if (!bgmSourceNode) {
                    bgmSourceNode = audioCtx.createMediaElementSource(bgmAudio);
                    bgmGainNode = audioCtx.createGain();
                    bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
                    bgmSourceNode.connect(bgmGainNode);
                    bgmGainNode.connect(audioCtx.destination);
                } else {
                    bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
                }

                await bgmAudio.play();
                isRunning = true;
                startBtn.innerText = "ÊºîÂî±‰∏≠...";
                stopBtn.disabled = false;
                statusText.innerText = "üé§ ÊºîÂî±‰∏≠";
                
                loop();

            } catch (e) {
                console.error(e);
                startBtn.disabled = false;
                startBtn.innerText = "ÂêØÂä®Â§±Ë¥•";
                statusText.innerText = "ËÆæÂ§áÂøô";
            }
        };

        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            frameCounter++;
            const currentTime = bgmAudio.currentTime;

            let targetPitch = 0;
            let currentNote = null;
            for(let i = renderIndex; i < currentMelodyData.length; i++) {
                const item = currentMelodyData[i];
                if (Math.abs(item.t - currentTime) < 0.15) { 
                    targetPitch = item.p;
                    currentNote = item;
                    break;
                }
                if (item.t > currentTime + 0.15) break; 
            }

            let userFreq = lastUserFreq;
            let userVolume = 0; // Áî®Êà∑Èü≥Èáè
            if (frameCounter % 3 === 0) {
                analyser.getFloatTimeDomainData(dataArray);
                // ËÆ°ÁÆóÈü≥ÈáèÔºàRMSÔºâ
                userVolume = calculateRMS(dataArray);
                // Ê†∏ÂøÉ‰ºòÂåñ1ÔºöÊèêÈ´òÈü≥ÈáèÈó®ÊßõÔºåÈò≤ÂëºÂê∏Â£∞
                const detected = getPitchAMDF(dataArray, audioCtx.sampleRate);
                
                if (detected > 0 && userVolume > VOLUME_THRESHOLD) {
                    userFreq = detected;
                    lastUserFreq = detected;
                } else {
                    if (frameCounter % 10 === 0) lastUserFreq = -1; 
                }

                // ËÆ°ÁÆóÈü≥ÈáèÊùÉÈáçÔºà0.8-1.2ÂÄçÔºåÈÅøÂÖçÊùÉÈáçËøáÂ§ßÂΩ±ÂìçÊª°ÂàÜÔºâ
                volumeWeight = Math.max(0.8, Math.min(1.2, userVolume / VOLUME_THRESHOLD));
                
                // 100ÂàÜÂà∂ËØÑÂàÜÈÄªËæëÔºàÊ†∏ÂøÉ‰ºòÂåñÔºâ
                if (targetPitch > 0 && totalNoteCount > 0) {
                    // Âä®ÊÄÅËÆ°ÁÆóÂçï‰∏™Èü≥Á¨¶Âü∫Á°ÄÂàÜÔºàÁ°Æ‰øùÊÄªÂàÜ‰∏çË∂ÖËøá100Ôºâ
                    const noteBase = MAX_SCORE / totalNoteCount;
                    const pitchAccuracy = calculatePitchAccuracy(userFreq, targetPitch);
                    let hitScore = 0;
                    
                    // ÂàÜÊ°£ËØÑÂàÜÔºàÊåâÈü≥ÂáÜÁ≤æÂ∫¶Ôºâ
                    if (pitchAccuracy >= (1 - PERFECT_RANGE) && userVolume > VOLUME_THRESHOLD) {
                        // ÂÆåÁæéÂëΩ‰∏≠ÔºöÂü∫Á°ÄÂàÜ√ó1.2√óÈü≥ÈáèÊùÉÈáç
                        hitScore = noteBase * 1.2 * volumeWeight;
                        perfectHitCount++;
                        comboCount++;
                        lastHitTime = currentTime;
                        hitNoteCount++;
                    } else if (pitchAccuracy >= (1 - GREAT_RANGE) && userVolume > VOLUME_THRESHOLD) {
                        // ‰ºòÁßÄÂëΩ‰∏≠ÔºöÂü∫Á°ÄÂàÜ√ó1.0√óÈü≥ÈáèÊùÉÈáç
                        hitScore = noteBase * 1.0 * volumeWeight;
                        comboCount++;
                        lastHitTime = currentTime;
                        hitNoteCount++;
                    } else if (pitchAccuracy >= (1 - GOOD_RANGE) && userVolume > VOLUME_THRESHOLD) {
                        // ËâØÂ•ΩÂëΩ‰∏≠ÔºöÂü∫Á°ÄÂàÜ√ó0.7√óÈü≥ÈáèÊùÉÈáç
                        hitScore = noteBase * 0.7 * volumeWeight;
                        comboCount++;
                        lastHitTime = currentTime;
                        hitNoteCount++;
                    } else {
                        // Êú™ÂëΩ‰∏≠ÔºöÈáçÁΩÆËøûÂáª+ÂàÜÊï∞Ë°∞Âáè
                        comboCount = 0;
                        const decayTime = currentTime - lastHitTime;
                        if (decayTime > 0.3) {
                            score = Math.max(0, score - SCORE_DECAY_RATE * decayTime);
                        }
                    }
                    
                    // ËøûÂáªÂ•ñÂä±ÔºàÊúÄÂ§ß1.5ÂÄçÔºåÈÅøÂÖçÊÄªÂàÜË∂Ö100Ôºâ
                    const comboMultiplier = 1 + Math.min(0.5, comboCount * COMBO_MULTIPLIER);
                    score += hitScore * comboMultiplier;
                    
                    // ÈôêÂà∂ÂàÜÊï∞‰∏äÈôêÔºà‰∏çË∂ÖËøá100Ôºâ
                    score = Math.min(MAX_SCORE, score);
                    
                    // Êõ¥Êñ∞ÊúÄÂ§ßËøûÂáª
                    maxCombo = Math.max(maxCombo, comboCount);
                } else {
                    // Êó†ÁõÆÊ†áÈü≥Á¨¶Êó∂ÔºåÂàÜÊï∞ÁºìÊÖ¢Ë°∞Âáè
                    score = Math.max(0, score - SCORE_DECAY_RATE * 0.1);
                    comboCount = 0;
                }
                
                // Êõ¥Êñ∞UIÊòæÁ§∫ÔºàÊï¥Êï∞ÂàÜÊï∞Ôºâ
                scoreEl.innerText = Math.floor(score);
                comboEl.innerText = comboCount;
            }
            
            ctx.fillStyle = 'rgba(20, 20, 35, 0.4)'; 
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); 

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            [130.81, 261.63, 523.25].forEach(freq => {
                const y = freqToY(freq);
                ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y);
            });
            ctx.stroke();

            const playerX = canvasWidth * 0.25;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(playerX, 0); ctx.lineTo(playerX, canvasHeight); ctx.stroke();

            if (renderIndex >= currentMelodyData.length || currentMelodyData[renderIndex].t > currentTime + 10) renderIndex = 0;
            while (renderIndex < currentMelodyData.length - 1 && currentMelodyData[renderIndex].t < currentTime - 1) renderIndex++;

            for (let i = renderIndex; i < currentMelodyData.length; i++) {
                const note = currentMelodyData[i];
                if (note.t > currentTime + VIEW_DURATION) break; 
                const drawX = playerX + (note.t - currentTime) / VIEW_DURATION * canvasWidth;
                if (note.p <= 0 || drawX < -30) continue; 
                const y = freqToY(note.p);
                
                // Ê†πÊçÆÈü≥ÂáÜÁ≤æÂ∫¶ÊòæÁ§∫‰∏çÂêåÈ¢úËâ≤
                let color = '#00d2ff'; 
                let shadowBlur = 0;
                
                if (Math.abs(drawX - playerX) < 15 && targetPitch > 0) { 
                    const accuracy = calculatePitchAccuracy(userFreq, targetPitch);
                    if (userFreq > 0 && userVolume > VOLUME_THRESHOLD) {
                        if (accuracy >= (1 - PERFECT_RANGE)) {
                            // ÂÆåÁæéÔºöÁôΩËâ≤È´ò‰∫Æ
                            color = '#ffffff';
                            shadowBlur = 15;
                        } else if (accuracy >= (1 - GREAT_RANGE)) {
                            // ‰ºòÁßÄÔºöÁªøËâ≤
                            color = '#00ff9d';
                            shadowBlur = 10;
                        } else if (accuracy >= (1 - GOOD_RANGE)) {
                            // ËâØÂ•ΩÔºöÈáëËâ≤
                            color = '#ffd700';
                            shadowBlur = 8;
                        } else {
                            // ÂÅèÂ∑ÆÔºöÊ©ôËâ≤
                            color = '#ff8800';
                            shadowBlur = 5;
                        }
                    }
                }
                
                ctx.fillStyle = color;
                ctx.shadowBlur = shadowBlur;
                ctx.shadowColor = color;
                drawRoundRect(ctx, drawX, y - NOTE_HEIGHT/2, 14, NOTE_HEIGHT, 6); 
                ctx.shadowBlur = 0; 
            }

            if (userFreq > 0 && userVolume > VOLUME_THRESHOLD) {
                const userY = freqToY(userFreq);
                ctx.beginPath();
                ctx.arc(playerX, userY, 12, 0, Math.PI * 2); 
                
                // Ê†πÊçÆÈü≥ÂáÜÊòæÁ§∫‰∏çÂêåÈ¢úËâ≤
                let fillColor = '#ff00de';
                let shadowColor = '#ff00de';
                let shadowBlur = 10;
                
                if (targetPitch > 0) {
                    const accuracy = calculatePitchAccuracy(userFreq, targetPitch);
                    if (accuracy >= (1 - PERFECT_RANGE)) {
                        fillColor = '#ffffff';
                        shadowColor = '#00d2ff';
                        shadowBlur = 20;
                    } else if (accuracy >= (1 - GREAT_RANGE)) {
                        fillColor = '#00ff9d';
                        shadowColor = '#00ff9d';
                        shadowBlur = 18;
                    } else if (accuracy >= (1 - GOOD_RANGE)) {
                        fillColor = '#ffd700';
                        shadowColor = '#ffd700';
                        shadowBlur = 15;
                    }
                }
                
                ctx.fillStyle = fillColor;
                ctx.shadowBlur = shadowBlur;
                ctx.shadowColor = shadowColor;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // ËÆ°ÁÆóÈü≥ÈáèÔºàRMSÂùáÊñπÊ†πÔºâ
        function calculateRMS(buffer) {
            let sum = 0;
            const sampleCount = Math.min(1000, buffer.length);
            for (let i = 0; i < sampleCount; i += 4) {
                sum += buffer[i] * buffer[i];
            }
            return Math.sqrt(sum / (sampleCount / 4));
        }

        // ËÆ°ÁÆóÈü≥ÂáÜÁ≤æÂ∫¶Ôºà0-1ÔºåË∂äÊé•Ëøë1Ë∂äÂáÜÔºâ
        function calculatePitchAccuracy(userFreq, targetFreq) {
            if (!userFreq || !targetFreq) return 0;
            const ratio = userFreq / targetFreq;
            // Â§ÑÁêÜÂÄçÈ¢ëÔºàÈ´òÂÖ´Â∫¶/‰ΩéÂÖ´Â∫¶Ôºâ
            const normalizedRatio = ratio > 2 ? ratio / 2 : ratio < 0.5 ? ratio * 2 : ratio;
            // ËÆ°ÁÆóÁ≤æÂ∫¶Ôºà1 - ËØØÂ∑ÆÂÄºÔºâ
            return 1 - Math.abs(1 - normalizedRatio);
        }

        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        function freqToY(freq) {
            const minF = 65, maxF = 1000;
            if (freq < minF) freq = minF;
            if (freq > maxF) freq = maxF;
            const percent = (Math.log(freq) - Math.log(minF)) / (Math.log(maxF) - Math.log(minF));
            return canvasHeight - (percent * canvasHeight);
        }

        function checkPitchHit(user, target) {
            if (!user || !target) return false;
            const ratio = user / target;
            const marginLow = 0.88, marginHigh = 1.12; 
            if (ratio > marginLow && ratio < marginHigh) return true; 
            if (ratio > (marginLow * 0.5) && ratio < (marginHigh * 0.5)) return true; 
            if (ratio > (marginLow * 2.0) && ratio < (marginHigh * 2.0)) return true; 
            return false;
        }

        function getPitchAMDF(buf, sampleRate) {
            const SIZE = buf.length, MAX_SAMPLES = 1000; 
            const minPeriod = Math.floor(sampleRate/800), maxPeriod = Math.floor(sampleRate/60);
            let minVal = Infinity, bestPeriod = 0;
            let rms = 0;
            for (let i = 0; i < MAX_SAMPLES; i += 4) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / (MAX_SAMPLES / 4));
            
            // ËøáÊª§‰ΩéÈü≥ÈáèÂô™Èü≥ÔºàÈò≤ÂëºÂê∏Â£∞Ôºâ
            if (rms < 0.1) return -1; 
            
            for (let offset = minPeriod; offset < maxPeriod; offset += 2) {
                let currentSum = 0;
                for (let i = 0; i < 300; i += 2) currentSum += Math.abs(buf[i] - buf[i + offset]);
                if (currentSum < minVal) { minVal = currentSum; bestPeriod = offset; }
            }
            return (minVal < 100) ? sampleRate / bestPeriod : -1;
        }
    </script>
</body>
</html>
