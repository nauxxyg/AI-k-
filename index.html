<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web Kæ­Œ</title>
    <style>
        /* =========================================
           1. å…¨å±€æ ·å¼ & åŠ¨æ€èƒŒæ™¯
           ========================================= */
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent; 
            touch-action: manipulation; /* ä¼˜åŒ–è§¦æ§å“åº” */
        }
        
        body { 
            /* é€‚é…ç«–å±çš„æ¸å˜èƒŒæ™¯ */
            background: linear-gradient(180deg, #0f0c29, #302b63, #24243e);
            color: #fff; 
            font-family: 'PingFang SC', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
            height: 100dvh; 
            width: 100vw;
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            user-select: none; 
            padding-bottom: env(safe-area-inset-bottom);
        }

        body::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.03) 0%, transparent 60%);
            animation: bgPulse 10s infinite alternate;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes bgPulse {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.1); opacity: 0.8; }
        }

        /* =========================================
           2. é¡¶éƒ¨æ ï¼ˆé€‚é…ç«–å±ï¼‰
           ========================================= */
        .top-bar {
            flex-shrink: 0; 
            height: 56px; 
            display: flex;
            flex-direction: column; /* ç«–å±æ”¹ä¸ºçºµå‘å¸ƒå±€ */
            justify-content: center;
            align-items: center;
            padding: 8px 16px;
            z-index: 20;
            background: rgba(20, 20, 35, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
        }

        .top-bar-content {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .select-wrapper {
            position: relative;
            width: 70%; /* ç«–å±è°ƒæ•´å®½åº¦ */
            max-width: none;
        }
        
        select {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            padding: 6px 30px 6px 15px;
            font-size: 14px; /* é€‚é…æ‰‹æœºå­—ä½“ */
            width: 100%;
            outline: none;
            appearance: none; 
            font-weight: 500;
            transition: all 0.3s;
        }
        select option {
            background-color: #1a1a1a;
            color: #fff;
            font-size: 14px;
        }
        select:focus {
            background: rgba(255, 255, 255, 0.2);
            border-color: #00d2ff;
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.3);
        }
        
        .select-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: 10px;
            color: #aaa;
        }

        .status-badge {
            font-size: 11px; /* é€‚é…æ‰‹æœºå­—ä½“ */
            color: #00d2ff;
            background: rgba(0, 210, 255, 0.1);
            padding: 4px 10px;
            border-radius: 20px;
            border: 1px solid rgba(0, 210, 255, 0.3);
            white-space: nowrap;
            letter-spacing: 0.5px;
            margin-left: 8px;
        }

        /* =========================================
           3. ç”»å¸ƒ & åˆ†æ•°ï¼ˆç«–å±é€‚é…ï¼‰
           ========================================= */
        #canvas-wrapper {
            flex: 1; 
            position: relative;
            width: 100%;
            background: transparent;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            min-height: 200px; /* ä¿è¯æœ€å°é«˜åº¦ */
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* åˆ†æ•°é¢æ¿ï¼šç«–å±è°ƒæ•´ä½ç½®åˆ°å³ä¸Šè§’ */
        .score-board {
            position: absolute;
            top: 12px;
            right: 15px;
            text-align: right;
            pointer-events: none;
            z-index: 15;
        }
        
        .score-value { 
            font-size: 42px; /* ç«–å±ç¼©å°å­—ä½“ */
            color: #fff; 
            font-weight: 900; 
            font-family: 'Segoe UI', Roboto, sans-serif; 
            text-shadow: 0 0 8px #ff00de, 0 0 15px #ff00de;
            line-height: 1;
        }
        .score-label { 
            font-size: 11px; 
            color: rgba(255,255,255,0.7); 
            letter-spacing: 2px; 
            font-weight: bold;
            margin-top: 3px;
        }

        /* è¿å‡»é¢æ¿ï¼šç«–å±è°ƒæ•´ä½ç½®åˆ°å·¦ä¸‹è§’ */
        .combo-board {
            position: absolute;
            bottom: 12px;
            left: 15px;
            text-align: left;
            pointer-events: none;
            z-index: 15;
        }
        .combo-value {
            font-size: 24px; /* ç«–å±ç¼©å°å­—ä½“ */
            color: #ffd700;
            font-weight: 900;
            text-shadow: 0 0 8px #ffd700, 0 0 15px #ffd700;
            line-height: 1;
        }
        .combo-label {
            font-size: 11px;
            color: rgba(255,255,255,0.7);
            letter-spacing: 1px;
            font-weight: bold;
        }

        /* =========================================
           4. åº•éƒ¨æ§åˆ¶æ ï¼ˆç«–å±ä¼˜åŒ–ï¼‰
           ========================================= */
        .bottom-controls {
            flex-shrink: 0; 
            width: 100%;
            padding: 12px 16px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            display: flex;
            flex-direction: column; /* ç«–å±æ”¹ä¸ºçºµå‘å¸ƒå±€ */
            gap: 12px;
            z-index: 20;
            background: rgba(20, 20, 35, 0.75);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.4);
        }

        /* éŸ³é‡æ§åˆ¶ï¼šç«–å±è°ƒæ•´å®½åº¦ */
        .vol-control {
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 6px;
        }
        
        .vol-header {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            padding: 0 2px;
        }
        .vol-num { color: #00d2ff; font-weight: bold; }

        input[type=range] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px; /* ç«–å±ç¼©å°æ»‘å— */
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
            border: 2px solid #00d2ff;
            transform: translateY(-1px);
        }

        /* æŒ‰é’®ç»„ï¼šç«–å±æ”¹ä¸ºæ¨ªå‘é“ºæ»¡ */
        .btn-group {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        .btn {
            flex: 1; /* æŒ‰é’®ç­‰åˆ†å®½åº¦ */
            height: 48px; /* ç«–å±è°ƒæ•´é«˜åº¦ */
            padding: 0 16px;
            border: none;
            border-radius: 24px;
            font-size: 15px; /* é€‚é…æ‰‹æœºå­—ä½“ */
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            white-space: nowrap;
            letter-spacing: 0.5px;
            position: relative;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .btn:active { transform: scale(0.96); }
        .btn:disabled { 
            background: #3a3a4c !important; 
            color: #888 !important; 
            box-shadow: none !important;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .btn-main {
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            box-shadow: 0 4px 20px rgba(0, 114, 255, 0.4);
        }
        .btn-stop {
            background: linear-gradient(135deg, #ff416c, #ff4b2b);
            box-shadow: 0 4px 20px rgba(255, 75, 43, 0.4);
        }

        /* =========================================
           5. ç§»é™¤æ¨ªå±æç¤ºï¼ˆä¸å†å¼ºåˆ¶æ¨ªå±ï¼‰
           ========================================= */
        #rotate-hint {
            display: none !important;
        }
    </style>
</head>
<body>

    <!-- ç§»é™¤å¼ºåˆ¶æ¨ªå±æç¤º -->
    <div id="rotate-hint" style="display: none;"></div>

    <!-- é¡¶éƒ¨æ ï¼ˆç«–å±é€‚é…ï¼‰ -->
    <div class="top-bar">
        <div class="top-bar-content">
            <div class="select-wrapper">
                <select id="songSelect">
                    <option value="">æ­£åœ¨åˆå§‹åŒ–...</option>
                </select>
                <div class="select-arrow">â–¼</div>
            </div>
            <div id="statusText" class="status-badge">ç­‰å¾…é€‰æ‹©</div>
        </div>
    </div>

    <!-- ç”»å¸ƒåŒºåŸŸï¼ˆç«–å±é€‚é…ï¼‰ -->
    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="score-board">
            <div class="score-value" id="scoreEl">0</div>
            <div class="score-label">SCORE</div>
        </div>
        <div class="combo-board">
            <div class="combo-value" id="comboEl">0</div>
            <div class="combo-label">COMBO</div>
        </div>
    </div>

    <!-- åº•éƒ¨æ§åˆ¶æ ï¼ˆç«–å±ä¼˜åŒ–ï¼‰ -->
    <div class="bottom-controls">
        <div class="vol-control">
            <div class="vol-header">
                <span>ğŸµ ä¼´å¥éŸ³é‡</span>
                <span class="vol-num" id="volText">70%</span>
            </div>
            <input type="range" id="volSlider" min="0" max="100" step="1" value="70">
        </div>
        
        <div class="btn-group">
            <button id="stopBtn" class="btn btn-stop" disabled>åœæ­¢</button>
            <button id="startBtn" class="btn btn-main" disabled>è¯·é€‰æ­Œ</button>
        </div>
    </div>

    <audio id="bgmAudio" crossorigin="anonymous"></audio>

    <script>
        // ==========================================
        //  Web Kæ­Œæ ¸å¿ƒå¼•æ“ - ç«–å±é€‚é…ç‰ˆï¼ˆ100åˆ†åˆ¶ï¼‰
        // ==========================================

        let playlist = [];
        let currentMelodyData = [];
        let audioCtx, analyser, micSource, bgmSourceNode, bgmGainNode;
        let dataArray;
        let isRunning = false;
        
        // è¯„åˆ†æ ¸å¿ƒå˜é‡ï¼ˆ100åˆ†åˆ¶ï¼‰
        let score = 0;
        let comboCount = 0;          // è¿å‡»æ•°
        let maxCombo = 0;            // æœ€å¤§è¿å‡»
        let totalNoteCount = 0;      // æ€»éŸ³ç¬¦æ•°
        let hitNoteCount = 0;        // å‘½ä¸­éŸ³ç¬¦æ•°
        let perfectHitCount = 0;     // å®Œç¾å‘½ä¸­æ•°
        let lastHitTime = 0;         // æœ€åå‘½ä¸­æ—¶é—´ï¼ˆé˜²è¡°å‡ï¼‰
        let volumeWeight = 1.0;      // éŸ³é‡æƒé‡
        
        let frameCounter = 0;
        let renderIndex = 0;
        let lastUserFreq = -1;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const songSelect = document.getElementById('songSelect');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn'); 
        const statusText = document.getElementById('statusText');
        const scoreEl = document.getElementById('scoreEl');
        const comboEl = document.getElementById('comboEl');
        const volSlider = document.getElementById('volSlider');
        const volText = document.getElementById('volText');
        const bgmAudio = document.getElementById('bgmAudio');

        let canvasWidth, canvasHeight;
        const VIEW_DURATION = 3.0; // ç«–å±ç¼©çŸ­å¯è§†æ—¶é•¿ï¼Œé€‚é…å±å¹•å®½åº¦
        const NOTE_HEIGHT = 12;    // ç«–å±ç¼©å°éŸ³ç¬¦é«˜åº¦
        // è¯„åˆ†å¸¸é‡ï¼ˆ100åˆ†åˆ¶æ ¸å¿ƒé…ç½®ï¼‰
        const MAX_SCORE = 100;       // æ»¡åˆ†100åˆ†
        const COMBO_MULTIPLIER = 0.05; // è¿å‡»ä¹˜æ•°ï¼ˆæ¯è¿å‡»+5%ï¼Œæœ€å¤§1.5å€ï¼‰
        const VOLUME_THRESHOLD = 0.1; // éŸ³é‡é˜ˆå€¼ï¼ˆè¿‡æ»¤å‘¼å¸å£°ï¼‰
        const SCORE_DECAY_RATE = 0.2; // åˆ†æ•°è¡°å‡ç‡ï¼ˆæ¯ç§’è¡°å‡2åˆ†ï¼‰
        const PERFECT_RANGE = 0.05;   // å®Œç¾éŸ³å‡†èŒƒå›´ï¼ˆÂ±5%ï¼‰
        const GREAT_RANGE = 0.10;     // ä¼˜ç§€éŸ³å‡†èŒƒå›´ï¼ˆÂ±10%ï¼‰
        const GOOD_RANGE = 0.15;      // è‰¯å¥½éŸ³å‡†èŒƒå›´ï¼ˆÂ±15%ï¼‰

        window.onload = async () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // éŸ³é‡æ»‘å—é€»è¾‘
            volSlider.oninput = () => {
                const val = parseInt(volSlider.value);
                volText.innerText = val + "%"; 
                const percent = (val / 100) * 100;
                volSlider.style.background = `linear-gradient(to right, #00d2ff 0%, #00d2ff ${percent}%, rgba(255,255,255,0.1) ${percent}%, rgba(255,255,255,0.1) 100%)`;

                if(bgmGainNode) {
                    bgmGainNode.gain.value = val / 100;
                }
            };
            volSlider.oninput();

            try {
                const res = await fetch('playlist.json?t=' + Date.now());
                playlist = await res.json();
                
                songSelect.innerHTML = '<option value="" disabled selected>ğŸ‘‰ é€‰æ‹©æ­Œæ›²</option>';
                playlist.forEach((song, index) => {
                    const opt = document.createElement('option');
                    opt.value = index;
                    opt.innerText = song.name;
                    songSelect.appendChild(opt);
                });
                
                songSelect.addEventListener('change', loadSongData);
                statusText.innerText = "å‡†å¤‡å°±ç»ª";
            } catch (e) {
                console.error(e);
                statusText.innerText = "åˆ—è¡¨åŠ è½½å¤±è´¥";
                alert("æ— æ³•è¯»å– playlist.json");
            }

            bgmAudio.addEventListener('ended', () => {
                finishGame("æ¼”å”±ç»“æŸ");
            });
        };

        // é€‚é…ç«–å±çš„ç”»å¸ƒå°ºå¯¸è°ƒæ•´
        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvasWidth = wrapper.clientWidth;
            canvasHeight = wrapper.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            ctx.resetTransform(); 
            ctx.scale(dpr, dpr);  
        }

        async function loadSongData() {
            const index = songSelect.value;
            const song = playlist[index];
            if (!song) return;

            resetGameStates(); 
            
            statusText.innerText = "ä¸‹è½½æ•°æ®...";
            startBtn.disabled = true;
            stopBtn.disabled = true;

            try {
                bgmAudio.src = song.mp3;
                const res = await fetch(song.json);
                currentMelodyData = await res.json();
                // ç»Ÿè®¡æ€»éŸ³ç¬¦æ•°ï¼ˆä»…æœ‰æ•ˆéŸ³ç¬¦ï¼‰
                totalNoteCount = currentMelodyData.filter(note => note.p > 0).length;
                
                statusText.innerText = "åŠ è½½å®Œæ¯•";
                startBtn.disabled = false;
                startBtn.innerText = "â–¶ å¼€å§‹æ¼”å”±";
                startBtn.classList.remove('btn-stop');
                startBtn.classList.add('btn-main');
            } catch (e) {
                console.error(e);
                statusText.innerText = "æ•°æ®é”™è¯¯";
                alert("åŠ è½½æ­Œæ›²æ•°æ®å¤±è´¥");
            }
        }

        function resetGameStates() {
            isRunning = false;
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
            renderIndex = 0;
            // é‡ç½®è¯„åˆ†å˜é‡
            score = 0;
            comboCount = 0;
            maxCombo = 0;
            totalNoteCount = 0;
            hitNoteCount = 0;
            perfectHitCount = 0;
            lastHitTime = 0;
            volumeWeight = 1.0;
            
            scoreEl.innerText = '0'; 
            comboEl.innerText = '0';
            frameCounter = 0;
            lastUserFreq = -1;
        }

        function finishGame(reason) {
            isRunning = false;
            startBtn.disabled = false;
            startBtn.innerText = "é‡æ–°å¼€å§‹";
            stopBtn.disabled = true;
            statusText.innerText = "ç»“ç®—ä¸­";
            
            // ç»“ç®—ç»Ÿè®¡ï¼ˆ100åˆ†åˆ¶ï¼‰
            const accuracy = totalNoteCount > 0 ? (hitNoteCount / totalNoteCount) * 100 : 0;
            const perfectRate = hitNoteCount > 0 ? (perfectHitCount / hitNoteCount) * 100 : 0;
            const finalScore = Math.min(MAX_SCORE, Math.max(0, Math.floor(score)));
            
            alert(`${reason}ï¼
æœ€ç»ˆå¾—åˆ†: ${finalScore} / ${MAX_SCORE}
æœ€å¤§è¿å‡»: ${maxCombo}
å‡†ç¡®ç‡: ${accuracy.toFixed(1)}%
å®Œç¾ç‡: ${perfectRate.toFixed(1)}%`);
        }

        stopBtn.onclick = () => {
            if (isRunning) {
                isRunning = false;
                bgmAudio.pause();
                bgmAudio.currentTime = 0;
                
                stopBtn.disabled = true;
                startBtn.disabled = false;
                startBtn.innerText = "é‡æ–°å¼€å§‹";
                statusText.innerText = "å·²åœæ­¢";
                
                // ç»“ç®—ç»Ÿè®¡
                const accuracy = totalNoteCount > 0 ? (hitNoteCount / totalNoteCount) * 100 : 0;
                const perfectRate = hitNoteCount > 0 ? (perfectHitCount / hitNoteCount) * 100 : 0;
                const finalScore = Math.min(MAX_SCORE, Math.max(0, Math.floor(score)));
                
                alert(`å·²åœæ­¢æ¼”å”±ã€‚
æœ€ç»ˆå¾—åˆ†: ${finalScore} / ${MAX_SCORE}
æœ€å¤§è¿å‡»: ${maxCombo}
å‡†ç¡®ç‡: ${accuracy.toFixed(1)}%
å®Œç¾ç‡: ${perfectRate.toFixed(1)}%`);
            }
        };

        startBtn.onclick = async () => {
            startBtn.disabled = true;
            startBtn.innerText = "å¯åŠ¨ä¸­...";
            stopBtn.disabled = true;

            resetGameStates();

            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            const tasks = [];
            if (audioCtx.state === 'suspended') tasks.push(audioCtx.resume());

            if (!micSource) {
                const micTask = navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: true, 
                        autoGainControl: false, 
                        noiseSuppression: false, 
                        latency: 0 
                    } 
                }).then(stream => {
                    micSource = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; 
                    micSource.connect(analyser);
                    dataArray = new Float32Array(analyser.fftSize);
                }).catch(e => {
                    alert("éº¦å…‹é£æƒé™è¢«æ‹’ç»");
                    throw e;
                });
                tasks.push(micTask);
            }

            if (bgmAudio.readyState < 3) bgmAudio.load();

            try {
                await Promise.all(tasks);

                if (!bgmSourceNode) {
                    bgmSourceNode = audioCtx.createMediaElementSource(bgmAudio);
                    bgmGainNode = audioCtx.createGain();
                    bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
                    bgmSourceNode.connect(bgmGainNode);
                    bgmGainNode.connect(audioCtx.destination);
                } else {
                    bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
                }

                await bgmAudio.play();
                isRunning = true;
                startBtn.innerText = "æ¼”å”±ä¸­...";
                stopBtn.disabled = false;
                statusText.innerText = "ğŸ¤ æ¼”å”±ä¸­";
                
                loop();

            } catch (e) {
                console.error(e);
                startBtn.disabled = false;
                startBtn.innerText = "å¯åŠ¨å¤±è´¥";
                statusText.innerText = "è®¾å¤‡å¿™";
            }
        };

        // ç«–å±é€‚é…çš„æ¸²æŸ“é€»è¾‘
        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            frameCounter++;
            const currentTime = bgmAudio.currentTime;

            let targetPitch = 0;
            let currentNote = null;
            for(let i = renderIndex; i < currentMelodyData.length; i++) {
                const item = currentMelodyData[i];
                if (Math.abs(item.t - currentTime) < 0.15) { 
                    targetPitch = item.p;
                    currentNote = item;
                    break;
                }
                if (item.t > currentTime + 0.15) break; 
            }

            let userFreq = lastUserFreq;
            let userVolume = 0;
            if (frameCounter % 3 === 0) {
                analyser.getFloatTimeDomainData(dataArray);
                userVolume = calculateRMS(dataArray);
                const detected = getPitchAMDF(dataArray, audioCtx.sampleRate);
                
                if (detected > 0 && userVolume > VOLUME_THRESHOLD) {
                    userFreq = detected;
                    lastUserFreq = detected;
                } else {
                    if (frameCounter % 10 === 0) lastUserFreq = -1; 
                }

                // éŸ³é‡æƒé‡ï¼ˆ0.8-1.2å€ï¼‰
                volumeWeight = Math.max(0.8, Math.min(1.2, userVolume / VOLUME_THRESHOLD));
                
                // 100åˆ†åˆ¶è¯„åˆ†é€»è¾‘
                if (targetPitch > 0 && totalNoteCount > 0) {
                    const noteBase = MAX_SCORE / totalNoteCount;
                    const pitchAccuracy = calculatePitchAccuracy(userFreq, targetPitch);
                    let hitScore = 0;
                    
                    // åˆ†æ¡£è¯„åˆ†
                    if (pitchAccuracy >= (1 - PERFECT_RANGE) && userVolume > VOLUME_THRESHOLD) {
                        hitScore = noteBase * 1.2 * volumeWeight;
                        perfectHitCount++;
                        comboCount++;
                        lastHitTime = currentTime;
                        hitNoteCount++;
                    } else if (pitchAccuracy >= (1 - GREAT_RANGE) && userVolume > VOLUME_THRESHOLD) {
                        hitScore = noteBase * 1.0 * volumeWeight;
                        comboCount++;
                        lastHitTime = currentTime;
                        hitNoteCount++;
                    } else if (pitchAccuracy >= (1 - GOOD_RANGE) && userVolume > VOLUME_THRESHOLD) {
                        hitScore = noteBase * 0.7 * volumeWeight;
                        comboCount++;
                        lastHitTime = currentTime;
                        hitNoteCount++;
                    } else {
                        comboCount = 0;
                        const decayTime = currentTime - lastHitTime;
                        if (decayTime > 0.3) {
                            score = Math.max(0, score - SCORE_DECAY_RATE * decayTime);
                        }
                    }
                    
                    // è¿å‡»å¥–åŠ±
                    const comboMultiplier = 1 + Math.min(0.5, comboCount * COMBO_MULTIPLIER);
                    score += hitScore * comboMultiplier;
                    score = Math.min(MAX_SCORE, score);
                    maxCombo = Math.max(maxCombo, comboCount);
                } else {
                    score = Math.max(0, score - SCORE_DECAY_RATE * 0.1);
                    comboCount = 0;
                }
                
                // æ›´æ–°UI
                scoreEl.innerText = Math.floor(score);
                comboEl.innerText = comboCount;
            }
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = 'rgba(20, 20, 35, 0.4)'; 
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); 

            // ç»˜åˆ¶å‚è€ƒçº¿ï¼ˆç«–å±é€‚é…ï¼‰
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            [130.81, 261.63, 523.25].forEach(freq => {
                const y = freqToY(freq);
                ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y);
            });
            ctx.stroke();

            // æ¼”å”±çº¿ï¼šç«–å±è°ƒæ•´ä½ç½®åˆ°å·¦ä¾§1/3å¤„
            const playerX = canvasWidth * 0.33;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath(); 
            ctx.moveTo(playerX, 0); 
            ctx.lineTo(playerX, canvasHeight); 
            ctx.stroke();

            // æ¸²æŸ“éŸ³ç¬¦ï¼ˆç«–å±é€‚é…ï¼‰
            if (renderIndex >= currentMelodyData.length || currentMelodyData[renderIndex].t > currentTime + 10) renderIndex = 0;
            while (renderIndex < currentMelodyData.length - 1 && currentMelodyData[renderIndex].t < currentTime - 1) renderIndex++;

            for (let i = renderIndex; i < currentMelodyData.length; i++) {
                const note = currentMelodyData[i];
                if (note.t > currentTime + VIEW_DURATION) break; 
                const drawX = playerX + (note.t - currentTime) / VIEW_DURATION * canvasWidth * 0.8; // ç«–å±ç¼©å°éŸ³ç¬¦ç§»åŠ¨èŒƒå›´
                if (note.p <= 0 || drawX < -20) continue; 
                const y = freqToY(note.p);
                
                // éŸ³ç¬¦é¢œè‰²æ ¹æ®ç²¾åº¦å˜åŒ–
                let color = '#00d2ff'; 
                let shadowBlur = 0;
                
                if (Math.abs(drawX - playerX) < 12 && targetPitch > 0) { // ç«–å±ç¼©å°åˆ¤å®šèŒƒå›´
                    const accuracy = calculatePitchAccuracy(userFreq, targetPitch);
                    if (userFreq > 0 && userVolume > VOLUME_THRESHOLD) {
                        if (accuracy >= (1 - PERFECT_RANGE)) {
                            color = '#ffffff';
                            shadowBlur = 12;
                        } else if (accuracy >= (1 - GREAT_RANGE)) {
                            color = '#00ff9d';
                            shadowBlur = 8;
                        } else if (accuracy >= (1 - GOOD_RANGE)) {
                            color = '#ffd700';
                            shadowBlur = 6;
                        } else {
                            color = '#ff8800';
                            shadowBlur = 4;
                        }
                    }
                }
                
                ctx.fillStyle = color;
                ctx.shadowBlur = shadowBlur;
                ctx.shadowColor = color;
                drawRoundRect(ctx, drawX, y - NOTE_HEIGHT/2, 12, NOTE_HEIGHT, 5); // ç«–å±ç¼©å°éŸ³ç¬¦å°ºå¯¸
                ctx.shadowBlur = 0; 
            }

            // ç»˜åˆ¶ç”¨æˆ·éŸ³é«˜æŒ‡ç¤ºå™¨ï¼ˆç«–å±é€‚é…ï¼‰
            if (userFreq > 0 && userVolume > VOLUME_THRESHOLD) {
                const userY = freqToY(userFreq);
                ctx.beginPath();
                ctx.arc(playerX, userY, 10, 0, Math.PI * 2); // ç«–å±ç¼©å°æŒ‡ç¤ºå™¨å°ºå¯¸
                
                let fillColor = '#ff00de';
                let shadowColor = '#ff00de';
                let shadowBlur = 8;
                
                if (targetPitch > 0) {
                    const accuracy = calculatePitchAccuracy(userFreq, targetPitch);
                    if (accuracy >= (1 - PERFECT_RANGE)) {
                        fillColor = '#ffffff';
                        shadowColor = '#00d2ff';
                        shadowBlur = 18;
                    } else if (accuracy >= (1 - GREAT_RANGE)) {
                        fillColor = '#00ff9d';
                        shadowColor = '#00ff9d';
                        shadowBlur = 15;
                    } else if (accuracy >= (1 - GOOD_RANGE)) {
                        fillColor = '#ffd700';
                        shadowColor = '#ffd700';
                        shadowBlur = 12;
                    }
                }
                
                ctx.fillStyle = fillColor;
                ctx.shadowBlur = shadowBlur;
                ctx.shadowColor = shadowColor;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // è®¡ç®—éŸ³é‡ï¼ˆRMSï¼‰
        function calculateRMS(buffer) {
            let sum = 0;
            const sampleCount = Math.min(1000, buffer.length);
            for (let i = 0; i < sampleCount; i += 4) {
                sum += buffer[i] * buffer[i];
            }
            return Math.sqrt(sum / (sampleCount / 4));
        }

        // è®¡ç®—éŸ³å‡†ç²¾åº¦
        function calculatePitchAccuracy(userFreq, targetFreq) {
            if (!userFreq || !targetFreq) return 0;
            const ratio = userFreq / targetFreq;
            const normalizedRatio = ratio > 2 ? ratio / 2 : ratio < 0.5 ? ratio * 2 : ratio;
            return 1 - Math.abs(1 - normalizedRatio);
        }

        // ç»˜åˆ¶åœ†è§’çŸ©å½¢ï¼ˆç«–å±é€‚é…ï¼‰
        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // é¢‘ç‡è½¬Yåæ ‡ï¼ˆç«–å±é€‚é…ï¼‰
        function freqToY(freq) {
            const minF = 65, maxF = 1000;
            if (freq < minF) freq = minF;
            if (freq > maxF) freq = maxF;
            const percent = (Math.log(freq) - Math.log(minF)) / (Math.log(maxF) - Math.log(minF));
            return canvasHeight - (percent * canvasHeight);
        }

        // éŸ³é«˜æ£€æµ‹ï¼ˆé˜²è¯¯è§¦ï¼‰
        function getPitchAMDF(buf, sampleRate) {
            const SIZE = buf.length, MAX_SAMPLES = 1000; 
            const minPeriod = Math.floor(sampleRate/800), maxPeriod = Math.floor(sampleRate/60);
            let minVal = Infinity, bestPeriod = 0;
            let rms = 0;
            for (let i = 0; i < MAX_SAMPLES; i += 4) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / (MAX_SAMPLES / 4));
            
            if (rms < 0.1) return -1; 
            
            for (let offset = minPeriod; offset < maxPeriod; offset += 2) {
                let currentSum = 0;
                for (let i = 0; i < 300; i += 2) currentSum += Math.abs(buf[i] - buf[i + offset]);
                if (currentSum < minVal) { minVal = currentSum; bestPeriod = offset; }
            }
            return (minVal < 100) ? sampleRate / bestPeriod : -1;
        }
    </script>
</body>
</html>
