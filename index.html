<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Web Kæ­Œ - æ­Œå•ç‰ˆ</title>
    <style>
        body { background: #111; color: white; display: flex; flex-direction: column; align-items: center; font-family: 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; margin: 0; }
        
        /* é¡¶éƒ¨æ§åˆ¶æ  */
        .top-bar {
            background: #222; width: 100%; padding: 15px; 
            display: flex; justify-content: center; gap: 20px; 
            align-items: center; box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            z-index: 10;
        }

        /* æ¼‚äº®çš„ä¸‹æ‹‰æ¡† */
        select {
            padding: 10px 15px; font-size: 16px; border-radius: 5px;
            background: #333; color: white; border: 1px solid #555;
            min-width: 200px; cursor: pointer;
        }

        /* ç”»å¸ƒ */
        #canvas-container {
            position: relative; width: 90%; height: 500px; background: #1a1a1a; 
            border: 2px solid #333; margin-top: 20px; border-radius: 10px;
        }
        canvas { width: 100%; height: 100%; display: block; border-radius: 10px; }
        
        .score-board {
            position: absolute; top: 20px; right: 30px; text-align: right;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px;
        }
        .score-num { font-size: 50px; color: #00ffcc; font-weight: bold; font-family: monospace; }
        
        /* åº•éƒ¨æ“ä½œåŒº */
        .bottom-controls {
            margin-top: 20px; width: 80%; display: flex; justify-content: space-between; align-items: center;
        }

        .vol-box { display: flex; align-items: center; gap: 10px; background: #333; padding: 10px 20px; border-radius: 30px;}
        input[type=range] { accent-color: #00ffcc; cursor: pointer; }

        .btn-main { 
            padding: 12px 40px; cursor: pointer; 
            background: linear-gradient(135deg, #00ffcc, #00b7ff); 
            color: #000; border: none; border-radius: 50px; 
            font-size: 18px; font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.4);
            transition: transform 0.2s;
        }
        .btn-main:active { transform: scale(0.95); }
        .btn-main:disabled { background: #555; color: #aaa; box-shadow: none; cursor: not-allowed;}

    </style>
</head>
<body>

    <div class="top-bar">
        <div style="font-weight:bold; color:#aaa;">å½“å‰æ›²ç›®:</div>
        <select id="songSelect" onchange="changeSong()">
            <option value="">æ­£åœ¨åŠ è½½æ­Œå•...</option>
        </select>
        <div id="loadingStatus" style="color:#00ffcc; font-size:14px; display:none;">åŠ è½½æ•°æ®ä¸­...</div>
    </div>

    <div id="canvas-container">
        <canvas id="gameCanvas"></canvas>
        <div class="score-board">
            <div style="font-size:14px; color:#aaa;">SCORE</div>
            <div class="score-num" id="scoreEl">0</div>
        </div>
    </div>

    <div class="bottom-controls">
        <div class="vol-box">
            <span>ğŸ”ˆ ä¼´å¥</span>
            <input type="range" id="volSlider" min="0" max="1" step="0.05" value="1" oninput="updateVolume(this.value)">
        </div>
        
        <button id="startBtn" class="btn-main" onclick="startSinging()" disabled>â–¶ å¼€å§‹æ¼”å”±</button>
        
        <div style="width: 150px;"></div> </div>

    <audio id="audio" style="display:none"></audio>

    <script>
        // --- å˜é‡å®šä¹‰ ---
        let playlist = []; // å­˜æ”¾æ­Œå•
        let currentMelodyData = []; 
        
        let audioCtx, analyser, micSource, trackSource, gainNode;
        let dataArray;
        let isRunning = false;
        let score = 0;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('audio');
        const songSelect = document.getElementById('songSelect');
        const startBtn = document.getElementById('startBtn');
        const loadingStatus = document.getElementById('loadingStatus');

        let canvasWidth, canvasHeight;
        const viewDuration = 5;

        // åˆå§‹åŒ–
        window.onload = init;
        window.onresize = resize;
        resize();

        function resize() {
            canvasWidth = canvas.clientWidth;
            canvasHeight = canvas.clientHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        // 1. åˆå§‹åŒ–ï¼šè¯»å–æ­Œå•
        async function init() {
            try {
                const res = await fetch('playlist.json');
                playlist = await res.json();
                
                // æ¸²æŸ“ä¸‹æ‹‰èœå•
                songSelect.innerHTML = '<option value="" disabled selected>-- è¯·é€‰æ‹©æ­Œæ›² --</option>';
                playlist.forEach((song, index) => {
                    const opt = document.createElement('option');
                    opt.value = index; // å­˜ç´¢å¼•
                    opt.innerText = song.name;
                    songSelect.appendChild(opt);
                });
                
                alert("æ­Œå•åŠ è½½æˆåŠŸï¼è¯·é€‰æ‹©ä¸€é¦–æ­Œæ›²ã€‚");
            } catch (e) {
                alert("æ— æ³•è¯»å–æ­Œå• playlist.jsonã€‚è¯·ç¡®ä¿è¿è¡Œäº† python è„šæœ¬å¹¶ç”Ÿæˆäº†æ–‡ä»¶ã€‚");
            }
        }

        // 2. åˆ‡æ­Œé€»è¾‘
        async function changeSong() {
            const index = songSelect.value;
            const song = playlist[index];
            if (!song) return;

            // é‡ç½®çŠ¶æ€
            isRunning = false;
            startBtn.disabled = true;
            loadingStatus.style.display = 'block';
            score = 0;
            document.getElementById('scoreEl').innerText = 0;
            
            // è®¾ç½®éŸ³é¢‘æº
            audio.src = song.mp3;
            
            // åŠ è½½ JSON æ•°æ®
            try {
                const res = await fetch(song.json);
                currentMelodyData = await res.json();
                
                loadingStatus.style.display = 'none';
                startBtn.disabled = false;
                startBtn.innerText = "â–¶ å¼€å§‹æ¼”å”±";
            } catch (e) {
                alert("åŠ è½½æ­Œæ›²æ•°æ®å¤±è´¥ï¼Œè¯·æ£€æŸ¥ json æ–‡ä»¶æ˜¯å¦å­˜åœ¨ã€‚");
                loadingStatus.style.display = 'none';
            }
        }

        // 3. å¼€å§‹æ¼”å”±
        async function startSinging() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            // è·å–éº¦å…‹é£ (åªè·å–ä¸€æ¬¡)
            if (!micSource) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048;
                    micSource = audioCtx.createMediaStreamSource(stream);
                    micSource.connect(analyser);
                    dataArray = new Float32Array(analyser.fftSize);
                } catch(e) {
                    alert("æ— æ³•è·å–éº¦å…‹é£æƒé™ï¼");
                    return;
                }
            }

            // é‡å»ºä¼´å¥é“¾è·¯ (æ¯æ¬¡åˆ‡æ­Œéƒ½è¦é‡æ–°è¿ï¼Œå› ä¸ºaudioå…ƒç´ å¯èƒ½å˜äº†æˆ–çŠ¶æ€é‡ç½®)
            // æ³¨æ„ï¼šä¸ºäº†é˜²æ­¢å¤šæ¬¡è¿æ¥æŠ¥é”™ï¼Œæˆ‘ä»¬ç”¨ try catch ç®€å•å¤„ç†ï¼Œæˆ–è€…æ¯æ¬¡æ–°å»º
            // æœ€ç¨³å¦¥çš„æ–¹å¼ï¼šå¤ç”¨ audioCtxï¼Œä½† GainNode å¯ä»¥é‡å»º
            if (trackSource) { 
                // å¦‚æœä¹‹å‰æœ‰æºï¼Œè¿™é‡Œä¸éœ€è¦æ–­å¼€ï¼Œå› ä¸º audio å…ƒç´ æ˜¯åŒä¸€ä¸ª DOM
            } else {
                trackSource = audioCtx.createMediaElementSource(audio);
                gainNode = audioCtx.createGain();
                gainNode.gain.value = document.getElementById('volSlider').value;
                trackSource.connect(gainNode).connect(audioCtx.destination);
            }
            
            audio.play();
            isRunning = true;
            startBtn.disabled = true;
            startBtn.innerText = "æ¼”å”±ä¸­...";
            loop();
        }

        // éŸ³é‡è°ƒèŠ‚
        function updateVolume(val) {
            if (gainNode) gainNode.gain.value = val;
            else audio.volume = val;
        }

        // --- æ ¸å¿ƒå¾ªç¯ (è·Ÿä¹‹å‰ä¸€æ ·) ---
        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            const currentTime = audio.currentTime;
            analyser.getFloatTimeDomainData(dataArray);
            const userFreq = autoCorrelate(dataArray, audioCtx.sampleRate);

            // ç»˜åˆ¶
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            drawGrid();

            // ç»˜åˆ¶ç›®æ ‡çº¿
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            let matchedTargetFreq = 0;

            for (let i = 0; i < currentMelodyData.length; i += 4) { // ç¨å¾®ç¨€ç–ä¸€ç‚¹æå‡æ€§èƒ½
                const point = currentMelodyData[i];
                if (point.t > currentTime - 1 && point.t < currentTime + viewDuration - 1) {
                    const x = (point.t - currentTime + 1) / viewDuration * canvasWidth; 
                    if (point.p > 0) {
                        const y = freqToY(point.p);
                        ctx.fillStyle = '#00ffcc';
                        ctx.fillRect(x, y, 5, 5);
                        
                        if (Math.abs(x - (canvasWidth * 0.2)) < 15) {
                            matchedTargetFreq = point.p;
                        }
                    }
                }
            }

            // åˆ¤å®šçº¿
            const playerX = canvasWidth * 0.2;
            ctx.beginPath();
            ctx.moveTo(playerX, 0);
            ctx.lineTo(playerX, canvasHeight);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.stroke();

            // ç”¨æˆ·å…‰æ ‡
            if (userFreq > 0) {
                const userY = freqToY(userFreq);
                ctx.beginPath();
                ctx.arc(playerX, userY, 15, 0, Math.PI*2);
                
                let hit = false;
                if (matchedTargetFreq > 0) {
                    const ratio = userFreq / matchedTargetFreq;
                    if (ratio > 0.94 && ratio < 1.06) hit = true;
                }

                if (hit) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ffcc';
                    score++;
                    document.getElementById('scoreEl').innerText = Math.floor(score / 5);
                } else {
                    ctx.fillStyle = '#ff0055';
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            if (audio.ended) {
                isRunning = false;
                startBtn.disabled = false;
                startBtn.innerText = "â–¶ é‡æ–°æ¼”å”±";
                alert("æ¼”å”±ç»“æŸï¼æ€»åˆ†: " + Math.floor(score/5));
            }
        }

        function freqToY(freq) {
            const minF = 65, maxF = 1000;
            if (freq < minF) freq = minF;
            if (freq > maxF) freq = maxF;
            const percent = (Math.log(freq) - Math.log(minF)) / (Math.log(maxF) - Math.log(minF));
            return canvasHeight - (percent * canvasHeight);
        }

        function drawGrid() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            [130, 261, 523].forEach(f => {
                let y = freqToY(f);
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
            });
            ctx.stroke();
        }

        function autoCorrelate(buf, sampleRate) {
            // (ç®—æ³•ä»£ç ä¿æŒä¸å˜ï¼Œä¸ºäº†ç¯‡å¹…çœç•¥ï¼Œè¯·ç›´æ¥å¤ç”¨ä¹‹å‰çš„ autoCorrelate å‡½æ•°)
            let SIZE = buf.length;
            let rms = 0;
            for (let i = 0; i < SIZE; i++) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / SIZE);
            if (rms < 0.05) return -1; 
            let r1 = 0, r2 = SIZE - 1, thres = 0.2;
            for (let i = 0; i < SIZE / 2; i++) if (Math.abs(buf[i]) < thres) { r1 = i; break; }
            for (let i = 1; i < SIZE / 2; i++) if (Math.abs(buf[SIZE - i]) < thres) { r2 = SIZE - i; break; }
            buf = buf.slice(r1, r2);
            SIZE = buf.length;
            let c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) for (let j = 0; j < SIZE - i; j++) c[i] = c[i] + buf[j] * buf[j + i];
            let d = 0; while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) if (c[i] > maxval) { maxval = c[i]; maxpos = i; }
            let T0 = maxpos;
            let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
            let a = (x1 + x3 - 2 * x2) / 2;
            let b = (x3 - x1) / 2;
            if (a) T0 = T0 - b / (2 * a);
            return sampleRate / T0;
        }
    </script>
</body>
</html>