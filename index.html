<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web KÊ≠å - ÊúÄÁªàÂÆåÁæéÁâà (ÂÅúÊ≠¢‰∏çÈáçÁΩÆ)</title>
    <style>
        /* =========================================
           1. ÂÖ®Â±ÄÊ†∑ÂºèÈáçÁΩÆ
           ========================================= */
        * { 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent; 
            touch-action: none; 
        }
        
        body { 
            background: #111; 
            color: #eee; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            height: 100dvh; 
            width: 100vw;
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            user-select: none; 
        }

        /* =========================================
           2. È°∂ÈÉ®Ê†è (Header)
           ========================================= */
        .top-bar {
            flex-shrink: 0; 
            background: #1a1a1a;
            width: 100%;
            height: 50px; 
            display: flex;
            justify-content: space-between; 
            align-items: center;
            padding: 0 15px;
            border-bottom: 1px solid #333;
            z-index: 20;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        select {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 20px;
            padding: 6px 25px 6px 15px;
            font-size: 14px;
            max-width: 65%; 
            outline: none;
            appearance: none; 
            text-overflow: ellipsis;
            white-space: nowrap;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: 8px auto;
        }

        .status-badge {
            font-size: 12px;
            color: #00ffcc;
            background: rgba(0, 255, 204, 0.1);
            padding: 4px 10px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 204, 0.2);
            white-space: nowrap;
        }

        /* =========================================
           3. Ê∏∏ÊàèÁîªÂ∏ÉÂå∫Âüü
           ========================================= */
        #canvas-wrapper {
            flex: 1; 
            position: relative;
            width: 100%;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .score-board {
            position: absolute;
            top: 15px;
            right: 20px;
            text-align: right;
            pointer-events: none;
            z-index: 10;
        }
        .score-value { 
            font-size: 48px; 
            color: #00ffcc; 
            font-weight: 800; 
            font-family: 'Helvetica Neue', Arial, sans-serif; 
            text-shadow: 0 0 15px rgba(0, 255, 204, 0.6);
            transition: transform 0.1s;
        }
        .score-label { font-size: 12px; color: #888; letter-spacing: 2px; text-transform: uppercase; }

        /* =========================================
           4. Â∫ïÈÉ®ÊéßÂà∂Ê†è
           ========================================= */
        .bottom-controls {
            flex-shrink: 0; 
            background: #1a1a1a;
            width: 100%;
            padding: 12px 20px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #333;
            gap: 15px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        }

        .vol-control {
            flex: 1; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 6px;
            background: #252525;
            padding: 8px 15px;
            height: 54px;
            border-radius: 12px;
            border: 1px solid #333;
        }
        
        .vol-header {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #aaa;
            width: 100%;
        }
        .vol-num { color: #00ffcc; font-weight: bold; font-family: monospace; }

        input[type=range] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            appearance: none;
            background: #444;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ffcc;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        .btn {
            height: 54px;
            padding: 0 16px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: bold;
            transition: transform 0.1s, filter 0.1s;
            white-space: nowrap;
        }
        .btn:active { transform: scale(0.95); filter: brightness(0.9); }
        .btn:disabled { 
            background: #333 !important; 
            color: #666 !important; 
            box-shadow: none !important; 
            transform: none !important;
            cursor: not-allowed;
        }

        .btn-main {
            min-width: 80px;
            background: linear-gradient(135deg, #00ffcc, #0099ff);
            color: #000;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.2);
        }

        .btn-stop {
            min-width: 60px;
            background: linear-gradient(135deg, #ff3366, #ff0033);
            color: #fff;
            box-shadow: 0 4px 15px rgba(255, 51, 102, 0.3);
        }

        /* =========================================
           5. Ê®™Â±èÊèêÁ§∫
           ========================================= */
        #rotate-hint {
            display: none;
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.92);
            z-index: 999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
        }
        .rotate-icon { font-size: 50px; margin-bottom: 20px; animation: rotateAnim 2s infinite; }
        .rotate-text { font-size: 18px; color: #ccc; }
        
        @keyframes rotateAnim {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-90deg); }
            100% { transform: rotate(-90deg); }
        }

        @media screen and (orientation: portrait) and (max-width: 600px) {
            #rotate-hint { display: flex; }
        }

        #bgmAudio { display: none; }
    </style>
</head>
<body>

    <div id="rotate-hint">
        <div class="rotate-icon">üì±</div>
        <div class="rotate-text">ËØ∑Â∞ÜÊâãÊú∫<b>Ê®™Â±è</b>‰ΩøÁî®<br>Ëé∑ÂæóÊúÄ‰Ω≥‰ΩìÈ™å</div>
    </div>

    <div class="top-bar">
        <select id="songSelect">
            <option value="">Ê≠£Âú®ÂàùÂßãÂåñ...</option>
        </select>
        <div id="statusText" class="status-badge">Á≠âÂæÖÈÄâÊã©</div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
        <div class="score-board">
            <div class="score-label">SCORE</div>
            <div class="score-value" id="scoreEl">0</div>
        </div>
    </div>

    <div class="bottom-controls">
        <div class="vol-control">
            <div class="vol-header">
                <span>üé§ ‰º¥Â•èÈü≥Èáè</span>
                <span class="vol-num" id="volText">70%</span>
            </div>
            <input type="range" id="volSlider" min="0" max="100" step="1" value="70">
        </div>
        
        <div class="btn-group">
            <button id="stopBtn" class="btn btn-stop" disabled>ÂÅúÊ≠¢</button>
            <button id="startBtn" class="btn btn-main" disabled>ËØ∑ÈÄâÊ≠å</button>
        </div>
    </div>

    <audio id="bgmAudio" crossorigin="anonymous"></audio>

    <script>
        // ==========================================
        //  Web KÊ≠åÊ†∏ÂøÉÂºïÊìé - Stop (No Reset) Version
        // ==========================================

        let playlist = [];
        let currentMelodyData = [];
        let audioCtx, analyser, micSource, bgmSourceNode, bgmGainNode;
        let dataArray;
        let isRunning = false;
        
        let score = 0;
        let totalVocalFrames = 0; 
        let hitVocalFrames = 0;   
        
        let frameCounter = 0;
        let renderIndex = 0;
        let lastUserFreq = -1;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const songSelect = document.getElementById('songSelect');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn'); 
        const statusText = document.getElementById('statusText');
        const scoreEl = document.getElementById('scoreEl');
        const volSlider = document.getElementById('volSlider');
        const volText = document.getElementById('volText');
        const bgmAudio = document.getElementById('bgmAudio');

        let canvasWidth, canvasHeight;
        const VIEW_DURATION = 4.0; 
        const NOTE_HEIGHT = 12;    

        window.onload = async () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            volSlider.oninput = () => {
                const val = parseInt(volSlider.value);
                volText.innerText = val + "%"; 
                if(bgmGainNode) {
                    bgmGainNode.gain.value = val / 100;
                }
            };

            try {
                const res = await fetch('playlist.json?t=' + Date.now());
                playlist = await res.json();
                
                songSelect.innerHTML = '<option value="" disabled selected>üëâ ÁÇπÂáªÈÄâÊã©Ê≠åÊõ≤</option>';
                playlist.forEach((song, index) => {
                    const opt = document.createElement('option');
                    opt.value = index;
                    opt.innerText = song.name;
                    songSelect.appendChild(opt);
                });
                
                songSelect.addEventListener('change', loadSongData);
                statusText.innerText = "ÂáÜÂ§áÂ∞±Áª™";
            } catch (e) {
                console.error(e);
                statusText.innerText = "ÂàóË°®Âä†ËΩΩÂ§±Ë¥•";
                alert("Êó†Ê≥ïËØªÂèñ playlist.json");
            }

            bgmAudio.addEventListener('ended', () => {
                finishGame("ÊºîÂî±ÁªìÊùü");
            });
        };

        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvasWidth = wrapper.clientWidth;
            canvasHeight = wrapper.clientHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            ctx.resetTransform(); 
            ctx.scale(dpr, dpr);  
        }

        async function loadSongData() {
            const index = songSelect.value;
            const song = playlist[index];
            if (!song) return;

            // Âä†ËΩΩÊñ∞Ê≠åÊó∂ÔºåÂÆåÂÖ®ÈáçÁΩÆ
            resetGameStates(); 
            
            statusText.innerText = "‰∏ãËΩΩÊï∞ÊçÆ...";
            startBtn.disabled = true;
            stopBtn.disabled = true;

            try {
                bgmAudio.src = song.mp3;
                const res = await fetch(song.json);
                currentMelodyData = await res.json();
                
                statusText.innerText = "Âä†ËΩΩÂÆåÊØï";
                startBtn.disabled = false;
                startBtn.innerText = "‚ñ∂ ÂºÄÂßãÊºîÂî±";
            } catch (e) {
                console.error(e);
                statusText.innerText = "Êï∞ÊçÆÈîôËØØ";
                alert("Âä†ËΩΩÊ≠åÊõ≤Êï∞ÊçÆÂ§±Ë¥•");
            }
        }

        // --- ÂÆåÊï¥Áä∂ÊÄÅÈáçÁΩÆ (Áî®‰∫éÊç¢Ê≠åÊàñÈáçÊñ∞ÂºÄÂßã) ---
        function resetGameStates() {
            isRunning = false;
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
            renderIndex = 0;
            score = 0;
            totalVocalFrames = 0;
            hitVocalFrames = 0;
            scoreEl.innerText = '0';
            frameCounter = 0;
            lastUserFreq = -1;
        }

        function finishGame(reason) {
            isRunning = false;
            startBtn.disabled = false;
            startBtn.innerText = "ÈáçÊñ∞ÂºÄÂßã";
            stopBtn.disabled = true;
            alert(`${reason}ÔºÅ\nÊúÄÁªàÂæóÂàÜ: ${score}`);
        }

        // --- ‰øÆÊîπÁÇπÔºöÂÅúÊ≠¢ÊåâÈíÆÈÄªËæë (‰∏çÈáçÁΩÆÁä∂ÊÄÅ) ---
        stopBtn.onclick = () => {
            if (isRunning) {
                // 1. ÂÅúÊ≠¢ËøêË°åÊ†áÂøó
                isRunning = false;
                // 2. ÊöÇÂÅúÈü≥‰πêÂπ∂ÂΩíÈõ∂ (‰∏ãÊ¨°ÂºÄÂßãÊòØÈáçÊñ∞ÂºÄÂßã)
                bgmAudio.pause();
                bgmAudio.currentTime = 0;
                
                // 3. UI Áä∂ÊÄÅÊõ¥Êñ∞
                stopBtn.disabled = true;
                startBtn.disabled = false;
                startBtn.innerText = "ÈáçÊñ∞ÂºÄÂßã";
                statusText.innerText = "Â∑≤ÂÅúÊ≠¢";
                
                // 4. Ê≥®ÊÑèÔºöËøôÈáå‰∏çË∞ÉÁî® resetGameStates()Ôºå‰øùÁïô score ÊòæÁ§∫
                alert(`Â∑≤ÂÅúÊ≠¢ÊºîÂî±„ÄÇ\nÊúÄÁªàÂæóÂàÜ: ${score}`);
            }
        };

        // --- ÂºÄÂßãÊ∏∏Êàè ---
        startBtn.onclick = async () => {
            startBtn.disabled = true;
            startBtn.innerText = "Ê≠£Âú®ÂêØÂä®...";
            stopBtn.disabled = true;

            // --- ÂÖ≥ÈîÆÔºöÊØèÊ¨°ÁÇπÂáªÂºÄÂßãÔºåÊâçÊòØÁúüÊ≠£ÁöÑÈáçÁΩÆÊó∂Âàª ---
            resetGameStates();

            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            const tasks = [];
            if (audioCtx.state === 'suspended') tasks.push(audioCtx.resume());

            if (!micSource) {
                const micTask = navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: true, 
                        autoGainControl: false, 
                        noiseSuppression: false, 
                        latency: 0 
                    } 
                }).then(stream => {
                    micSource = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048; 
                    micSource.connect(analyser);
                    dataArray = new Float32Array(analyser.fftSize);
                }).catch(e => {
                    alert("È∫¶ÂÖãÈ£éÊùÉÈôêË¢´ÊãíÁªù");
                    throw e;
                });
                tasks.push(micTask);
            }

            if (bgmAudio.readyState < 3) bgmAudio.load();

            try {
                await Promise.all(tasks);

                if (!bgmSourceNode) {
                    bgmSourceNode = audioCtx.createMediaElementSource(bgmAudio);
                    bgmGainNode = audioCtx.createGain();
                    bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
                    bgmSourceNode.connect(bgmGainNode);
                    bgmGainNode.connect(audioCtx.destination);
                } else {
                    bgmGainNode.gain.value = parseInt(volSlider.value) / 100;
                }

                await bgmAudio.play();
                isRunning = true;
                startBtn.innerText = "ÊºîÂî±‰∏≠...";
                stopBtn.disabled = false; // ÂêØÁî®ÂÅúÊ≠¢ÊåâÈíÆ
                
                loop();

            } catch (e) {
                console.error(e);
                startBtn.disabled = false;
                startBtn.innerText = "ÂêØÂä®Â§±Ë¥•";
                statusText.innerText = "Á°¨‰ª∂Âç†Áî®‰∏≠";
            }
        };

        // --- ‰∏ªÂæ™ÁéØ ---
        function loop() {
            if (!isRunning) return;
            requestAnimationFrame(loop);

            frameCounter++;
            const currentTime = bgmAudio.currentTime;

            let targetPitch = 0;
            for(let i = renderIndex; i < currentMelodyData.length; i++) {
                const item = currentMelodyData[i];
                if (Math.abs(item.t - currentTime) < 0.15) { 
                    targetPitch = item.p;
                    break;
                }
                if (item.t > currentTime + 0.15) break; 
            }

            let userFreq = lastUserFreq;
            if (frameCounter % 3 === 0) {
                analyser.getFloatTimeDomainData(dataArray);
                const detected = getPitchAMDF(dataArray, audioCtx.sampleRate);
                
                if (detected > 0) {
                    userFreq = detected;
                    lastUserFreq = detected;
                } else {
                    if (frameCounter % 10 === 0) lastUserFreq = -1; 
                }

                if (targetPitch > 0) {
                    totalVocalFrames++; 
                    if (userFreq > 0 && checkPitchHit(userFreq, targetPitch)) {
                        hitVocalFrames++;
                    }
                    if (totalVocalFrames > 0) {
                        score = Math.floor((hitVocalFrames / totalVocalFrames) * 100);
                        scoreEl.innerText = score;
                    }
                }
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            [130.81, 261.63, 523.25].forEach(freq => {
                const y = freqToY(freq);
                ctx.moveTo(0, y); ctx.lineTo(canvasWidth, y);
            });
            ctx.stroke();

            const playerX = canvasWidth * 0.25;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(playerX, 0); ctx.lineTo(playerX, canvasHeight); ctx.stroke();

            if (renderIndex >= currentMelodyData.length || currentMelodyData[renderIndex].t > currentTime + 10) renderIndex = 0;
            while (renderIndex < currentMelodyData.length - 1 && currentMelodyData[renderIndex].t < currentTime - 1) renderIndex++;

            for (let i = renderIndex; i < currentMelodyData.length; i++) {
                const note = currentMelodyData[i];
                if (note.t > currentTime + VIEW_DURATION) break; 
                const drawX = playerX + (note.t - currentTime) / VIEW_DURATION * canvasWidth;
                if (note.p <= 0 || drawX < -30) continue; 
                const y = freqToY(note.p);
                let color = '#00eebb'; 
                if (Math.abs(drawX - playerX) < 15) { 
                     if (userFreq > 0 && targetPitch > 0 && checkPitchHit(userFreq, targetPitch)) {
                         color = '#ffffff'; 
                     }
                }
                ctx.fillStyle = color;
                drawRoundRect(ctx, drawX, y - NOTE_HEIGHT/2, 14, NOTE_HEIGHT, 5);
            }

            if (userFreq > 0) {
                const userY = freqToY(userFreq);
                ctx.beginPath();
                ctx.arc(playerX, userY, 10, 0, Math.PI * 2);
                if (targetPitch > 0 && checkPitchHit(userFreq, targetPitch)) {
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffcc';
                } else {
                    ctx.fillStyle = '#ff3366'; 
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // ËæÖÂä©ÂáΩÊï∞
        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        function freqToY(freq) {
            const minF = 65, maxF = 1000;
            if (freq < minF) freq = minF;
            if (freq > maxF) freq = maxF;
            const percent = (Math.log(freq) - Math.log(minF)) / (Math.log(maxF) - Math.log(minF));
            return canvasHeight - (percent * canvasHeight);
        }

        function checkPitchHit(user, target) {
            if (!user || !target) return false;
            const ratio = user / target;
            const marginLow = 0.88, marginHigh = 1.12; 
            if (ratio > marginLow && ratio < marginHigh) return true; 
            if (ratio > (marginLow * 0.5) && ratio < (marginHigh * 0.5)) return true; 
            if (ratio > (marginLow * 2.0) && ratio < (marginHigh * 2.0)) return true; 
            return false;
        }

        function getPitchAMDF(buf, sampleRate) {
            const SIZE = buf.length, MAX_SAMPLES = 1000; 
            const minPeriod = Math.floor(sampleRate/800), maxPeriod = Math.floor(sampleRate/60);
            let minVal = Infinity, bestPeriod = 0;
            let rms = 0;
            for (let i = 0; i < MAX_SAMPLES; i += 4) rms += buf[i] * buf[i];
            rms = Math.sqrt(rms / (MAX_SAMPLES / 4));
            if (rms < 0.04) return -1; 
            for (let offset = minPeriod; offset < maxPeriod; offset += 2) {
                let currentSum = 0;
                for (let i = 0; i < 300; i += 2) currentSum += Math.abs(buf[i] - buf[i + offset]);
                if (currentSum < minVal) { minVal = currentSum; bestPeriod = offset; }
            }
            return (minVal < 120) ? sampleRate / bestPeriod : -1;
        }
    </script>
</body>
</html>
